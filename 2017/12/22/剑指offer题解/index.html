<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    
    
    
    
    <title>牛客网《剑指Offer》66题 题解 | wuqiansheng</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="python,剑指Offer">
    <meta name="description" content="字符串的排列  输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述: 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。  dfs， 但是牛客网有些尴尬，list的顺序还得保障，所以结果得sort一下。为了防止重复，用了set。">
<meta name="keywords" content="python,剑指Offer">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客网《剑指Offer》66题 题解">
<meta property="og:url" content="http://wuqiansheng.xyz/2017/12/22/剑指offer题解/index.html">
<meta property="og:site_name" content="wuqiansheng">
<meta property="og:description" content="字符串的排列  输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述: 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。  dfs， 但是牛客网有些尴尬，list的顺序还得保障，所以结果得sort一下。为了防止重复，用了set。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20160616/716804_1466088939214_DB8DE8E90C58DADF4C1048A7B110E8E5">
<meta property="og:image" content="http://images.cnitblog.com/blog/528669/201407/230518072134822.png">
<meta property="og:image" content="http://wuqiansheng.xyz/images/剑指offer_55.png">
<meta property="og:updated_time" content="2018-04-11T09:11:03.040Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="牛客网《剑指Offer》66题 题解">
<meta name="twitter:description" content="字符串的排列  输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述: 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。  dfs， 但是牛客网有些尴尬，list的顺序还得保障，所以结果得sort一下。为了防止重复，用了set。">
<meta name="twitter:image" content="https://uploadfiles.nowcoder.com/images/20160616/716804_1466088939214_DB8DE8E90C58DADF4C1048A7B110E8E5">
    
        <link rel="alternate" type="application/atom+xml" title="wuqiansheng" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://avatars2.githubusercontent.com/u/7495016?s=460&v=4)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="http://7xso5r.com1.z0.glb.clouddn.com/avstar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">wqs</h5>
          <a href="mailto:wuqiansheng@foxmail.com" title="wuqiansheng@foxmail.com" class="mail">wuqiansheng@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/QianShengWu" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-link"></i>
                友链
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">牛客网《剑指Offer》66题 题解</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">牛客网《剑指Offer》66题 题解</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-12-22T11:12:00.000Z" itemprop="datePublished" class="page-time">
  2017-12-22
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    

<article id="post-剑指offer题解"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">牛客网《剑指Offer》66题 题解</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-12-22 19:12:00" datetime="2017-12-22T11:12:00.000Z"  itemprop="datePublished">2017-12-22</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <ol type="1">
<li><p>字符串的排列</p>
<blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p>输入描述:</p>
<p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
</blockquote>
<p>dfs， 但是牛客网有些尴尬，list的顺序还得保障，所以结果得sort一下。为了防止重复，用了set。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss: <span class="keyword">return</span> []</span><br><span class="line">        res = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(res, ss, s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss: res.add(s)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                s = s + ss[i]</span><br><span class="line">                dfs(res, ss[:i] + ss[i + <span class="number">1</span>:], s)</span><br><span class="line">                s = s[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        dfs(res, ss, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> sorted(list(res))</span><br></pre></td></tr></table></figure>
<p>当然，这只是简单得写法。高级得用swap实现，详情见STL中得permutation经典算法。</p></li>
</ol>
<a id="more"></a>
<p>​</p>
<ol start="2" type="1">
<li><p>链表中倒数第k个结点</p>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>先求链表长度n，然后输出第n-k节点。注意k&gt;n的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">if</span> k &gt; n: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        t = n - k</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(t):</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure></li>
<li><p>跳台阶</p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p><span class="math display">\[f(n)=f(n-1)+f(n-2), f(0)=f(1)=1\]</span>，斐波那契数列的变体。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(number):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></li>
<li><p>变态跳台阶</p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>数学推导：<span class="math display">\[f(n)=f(n-1)+f(n-2)+...+f(1)\]</span>，<span class="math display">\[f(n-1)=f(n-2)+f(n-3)+...+f(1)\]</span></p>
<p><span class="math display">\[f(1)=1\]</span>，因而有<span class="math display">\[f(n)=2f(n-1)=2^{n-1}\]</span>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> ** (number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>不用加减乘除做加法</p>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<p>也就是用二进制的加法，二进制位相加用异或，进位用与并左移一位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            tmp = num1 ^ num2;</span><br><span class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述的实现有些技巧，主要利用c++整数逸出会变0解决<span class="math display">\[-1+1=0\]</span>的情况，而python则没有逸出的概念，所以我们要与上0xffffffff。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: int</span></span><br><span class="line"><span class="string">        :type b: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 32 bits integer max</span></span><br><span class="line">        MAX = <span class="number">0x7FFFFFFF</span></span><br><span class="line">        <span class="comment"># 32 bits interger min</span></span><br><span class="line">        MIN = <span class="number">0x80000000</span></span><br><span class="line">        <span class="comment"># mask to get last 32 bits</span></span><br><span class="line">        mask = <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry</span></span><br><span class="line">            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; <span class="number">1</span>) &amp; mask</span><br><span class="line">        <span class="comment"># if a is negative, get a's 32 bits complement positive first</span></span><br><span class="line">        <span class="comment"># then get 32-bit positive's Python complement negative</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= MAX <span class="keyword">else</span> ~(a ^ mask)</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>替换空格</p>
<blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">import</span> re</span><br><span class="line">        s = re.sub(<span class="string">' '</span>, <span class="string">'%20'</span>, s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>顺序针打印矩阵</p>
<blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> matrix <span class="keyword">and</span> list(matrix.pop(<span class="number">0</span>)) + self.printMatrix(list(zip(*matrix))[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>二维数组中的查找</p>
<blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p>类似二叉搜索树，从右上角开始依次左、下遍历，或者从左下角开始依次上、右遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        m, n = len(array), len(array[<span class="number">0</span>])</span><br><span class="line">        i, j = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[i][j] == target: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> array[i][j] &lt; target: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>包含min函数的栈</p>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
</blockquote>
<p>同时维护一个最小栈。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minstack = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minstack:</span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        <span class="keyword">elif</span> node &lt; self.minstack[<span class="number">-1</span>]:</span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minstack.append(self.minstack[<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.minstack.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>重建二叉树</p></li>
</ol>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> inorder:</span><br><span class="line">            id = inorder.index(preorder.pop(<span class="number">0</span>))</span><br><span class="line">            root = TreeNode(inorder[id])</span><br><span class="line">            root.left = self.reConstructBinaryTree(preorder, inorder[:id])</span><br><span class="line">            root.right = self.reConstructBinaryTree(preorder, inorder[id+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>​</p>
<ol start="11" type="1">
<li><p>用两个栈实现队列</p>
<blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<p>一个in栈，一个out栈，in栈用于直接push，out栈用于逆向pop in 栈中的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.instack = []</span><br><span class="line">        self.outstack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.instack.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.outstack:</span><br><span class="line">            <span class="keyword">while</span> self.instack:</span><br><span class="line">                self.outstack.append(self.instack.pop())</span><br><span class="line">        <span class="keyword">return</span> self.outstack.pop()</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>旋转数组的最小数字</p>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p>二分查找的变体，采用左闭右开的写法，维持l是最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, h = <span class="number">0</span>, len(rotateArray) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            m = (l + h) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[m] &gt; rotateArray[h]:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = m</span><br><span class="line">        <span class="keyword">return</span> rotateArray[l]</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>斐波那契数列</p>
<blockquote>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。</p>
<p>n&lt;=39</p>
</blockquote>
<p>用a, b 两个变量记录前后两个斐波那契数，c记录第几个。(注意n=0, 0)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> c &lt; n:</span><br><span class="line">            b, a, c = a, a + b, c + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>矩阵覆盖</p>
<blockquote>
<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</blockquote>
<p>还是斐波那契的变体形式，不想写递推了，直接递归实现。不过python会超时，所以改用java拉。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20160616/716804_1466088939214_DB8DE8E90C58DADF4C1048A7B110E8E5"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二进制中1的个数</p>
<blockquote>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>先求出二进制，然后不同向右移位，统计最低位为1的数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([(n &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>)])</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>数值的整数次方</p>
<blockquote>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> base ** exponent</span><br></pre></td></tr></table></figure>
<p>当然有高深的解法，也就是==&gt;快速幂.(https://www.cnblogs.com/CXCXCXC/p/4641812.html)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> exponent:</span><br><span class="line">            <span class="keyword">if</span> exponent &amp; <span class="number">1</span>: ans *= base</span><br><span class="line">            base *= base</span><br><span class="line">            exponent &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>这种再牛客网上提交会超时，毕竟python，时间限制的严。但是这确实是O(log n)的解法。</p>
<p>主要思想是分解exponent，如base=a, exponent=11, <span class="math display">\[11=2^3+2^1+2^0=1011\]</span>，也就是说 <span class="math display">\[
a^{11}=a^{2^0+2^1+2^3}=a^*a^*a^
\]</span> 也就是不停判断exponent的最低一位，a则不停翻倍，实现a=&gt;a<sup>2</sup>=&gt;a<sup>3</sup> ，如果b的最低位是1就乘上去呗。</p></li>
<li><p>调整数组顺序使奇数位于偶数前面</p>
<blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<p>类似冒泡算法，前偶后奇数就交换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        n = len(array)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> array[j] &amp; <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> array[j - <span class="number">1</span>] &amp; <span class="number">1</span>:</span><br><span class="line">                    array[j], array[j<span class="number">-1</span>] = array[j<span class="number">-1</span>], array[j]</span><br></pre></td></tr></table></figure>
<p>当然最简单的还是耗空间的解法，遍历楼。</p>
<p>​</p></li>
<li><p>反转链表</p>
<blockquote>
<p>输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<p>链表经典题型拉。三个指针拉，pre, cur, pos。cur.next = pre是关键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            pos = pHead.next</span><br><span class="line">            pHead.next = pre</span><br><span class="line">            pre = pHead</span><br><span class="line">            pHead = pos</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></li>
<li><p>合并两个排序的链表</p>
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<p>归并排序呗。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        L = ListNode(<span class="number">0</span>)</span><br><span class="line">        p, p1, p2 = L, pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt;= p2.val:</span><br><span class="line">                p.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">if</span> p1: p.next = p1</span><br><span class="line">        <span class="keyword">if</span> p2: p.next = p2</span><br><span class="line">        <span class="keyword">return</span> L.next</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>树的子结构</p>
<blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<p>递归查找呗</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot2 <span class="keyword">or</span> <span class="keyword">not</span> pRoot1: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.isSame(pRoot1, pRoot2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSame</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">and</span> p2: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> p1.val != p2.val: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSame(p1.left, p2.left) <span class="keyword">and</span> self.isSame(p1.right, p2.right)</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>二叉树的镜像</p>
<blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义：源二叉树</p>
</blockquote>
<pre><code>        8
       /  \
      6   10
     / \  / \
    5  7 9 11
    镜像二叉树
        8
       /  \
      10   6
     / \  / \
    11 9 7  5</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>栈的压入、弹出序列</p>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<p>借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p>举例：</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<p>….</p>
<p>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        n = len(pushV)</span><br><span class="line">        s = []</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> pushV:</span><br><span class="line">            s.append(v)</span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> s[<span class="number">-1</span>] == popV[j]:</span><br><span class="line">                s.pop()</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>从上往下打印二叉树</p>
<blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<p>树的层次遍历，队列实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue, res = [root], []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                res.append(p.val)</span><br><span class="line">                <span class="keyword">if</span> p.left: tmp.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right: tmp.append(p.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>二叉搜索树的后序遍历序列</p>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p>分治拉， 后序遍历是这样的（小于根节点，大于根节点， 根节点），找到小于和大于的分界线，从右向左查找，然后递归判断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.verfify(sequence, <span class="number">0</span>, len(sequence) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verfify</span><span class="params">(self, sequence, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        i = end - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= start <span class="keyword">and</span> sequence[i] &gt; sequence[end]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; start: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(start, i + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> sequence[j] &gt; sequence[end]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.verfify(sequence, start, i) <span class="keyword">and</span> self.verfify(sequence, i + <span class="number">1</span>, end - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>二叉树中和为某一值的路径</p>
<blockquote>
<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
</blockquote>
<p>dfs</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, expectNumber, path)</span>:</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == expectNumber: res.append(path[:])</span><br><span class="line">            <span class="keyword">if</span> root.left: dfs(root.left, expectNumber - root.val, path)</span><br><span class="line">            <span class="keyword">if</span> root.right: dfs(root.right, expectNumber - root.val, path)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        dfs(root, expectNumber, path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>复杂链表的复制</p>
<blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
</blockquote>
<p>最简单的方法，先复制一遍不带random的链表，并用字典记录random的指向，第二遍遍历修复random项。复杂度是O(2n)，空间复杂度O(n)。</p>
<p>O(1)空间的解法如下：</p>
<ol type="1">
<li>在原链表的每个节点后面拷贝出一个新的节点</li>
<li>依次给新的节点的随机指针赋值，而且这个赋值非常容易 cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</li>
<li>断开链表可得到深度拷贝后的新链表</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.random = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        dic = dict()</span><br><span class="line">        L = RandomListNode(<span class="number">0</span>)</span><br><span class="line">        p, cur = L, pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = RandomListNode(cur.label)</span><br><span class="line">            dic[cur] = tmp</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p, cur = p.next, cur.next</span><br><span class="line"></span><br><span class="line">        p, cur = L.next, pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            p.random = dic.get(cur.random, <span class="keyword">None</span>)</span><br><span class="line">            p, cur = p.next, cur.next</span><br><span class="line">        <span class="keyword">return</span> L.next</span><br></pre></td></tr></table></figure></li>
<li><p>二叉搜索树与双向链表</p>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<p>left指向前一个节点，right指向后一个节点，中序遍历。维护一个left最右的指针，然后修正leftmost, root, right之间的关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    leftlast = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, root)</span>:</span> <span class="comment"># 返回最小的那个节点。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            self.leftlast = root</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.Convert(root.left)</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            self.leftlast.right = root</span><br><span class="line">            root.left = self.leftlast</span><br><span class="line">        self.leftlast = root</span><br><span class="line">        right = self.Convert(root.right)</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            right.left = root</span><br><span class="line">            root.right = right</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> root</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>数组中出现次数超过一半的数字</p>
<blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<p>最简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        c = Counter(numbers).most_common(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> c[<span class="number">0</span>] <span class="keyword">if</span> c[<span class="number">1</span>] &gt; len(numbers)/<span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>复杂点， 借用众数得思想，一次在数组中删除两个不同得数，直到剩下一个数，如果这个数出现得次数大于一半，这个数最后一定会剩下来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        cand, times = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> times == <span class="number">0</span>:</span><br><span class="line">                cand, times = number, <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cand == number:</span><br><span class="line">                times += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                times -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> number == cand:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cand <span class="keyword">if</span> c &gt; len(numbers) / <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>最小的K个数</p>
<blockquote>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<p>可以用快排，可以用最小堆，还有牛逼得BFPRT算法。</p>
<p>只能说牛客网比较奇葩，返回结果还需要排序，我去，下列代码会超时，so不如用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">class Solution:</span><br><span class="line">    def GetLeastNumbers_Solution(self, a, k):</span><br><span class="line">        if k &gt; len(a): return []</span><br><span class="line">        l, h = 0, len(a) - 1</span><br><span class="line">        i = self.partition(a, l, h)</span><br><span class="line">        while i != k - 1:</span><br><span class="line">            if i &gt; k - 1:</span><br><span class="line">                i = self.partition(a, l, i - 1)</span><br><span class="line">            else:</span><br><span class="line">                i = self.partition(a, i + 1, h)</span><br><span class="line">        return [a[i] for i in range(k)]</span><br><span class="line"></span><br><span class="line">    def partition(self, a, l, h):</span><br><span class="line">        tmp = a[l]</span><br><span class="line">        while l &lt; h:</span><br><span class="line">            while l &lt; h and a[h] &gt;= tmp: h -= 1</span><br><span class="line">            a[l] = a[h]</span><br><span class="line">            while l &lt; h and a[l] &lt;= tmp: l += 1</span><br><span class="line">            a[h] = a[l]</span><br><span class="line">        a[l] = tmp</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure></p>
<p>​</p></li>
<li><p>连续子数组的最大和</p>
<blockquote>
<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
</blockquote>
<p>_sum局部累加和，_max全部最大和。注意里面_max得初始值，和求max得顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        _max, _sum = <span class="number">-0x80000000</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            _sum += i</span><br><span class="line">            _max = max(_sum, _max) <span class="comment">#写在下一句之前，保证_max可以为负数</span></span><br><span class="line">            <span class="keyword">if</span> _sum &lt; <span class="number">0</span>: _sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> _max</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>整数中1出现的次数（从1到n整数中1出现的次数）</p>
<blockquote>
<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
</blockquote>
<p>详解：https://leetcode.com/problems/number-of-digit-one/discuss/64381</p>
<p>把数字划分为两部分，如n=3141592, 考虑百分位，m=100, 则a=31415, b = 92 ，然后我们知道n的百分位为1的前缀是从‘’“到3141，共3142次，后缀都是100次，也就是<span class="math display">\[(a/10 + 1) * 100\]</span>。</p>
<p>再考虑千分位，m=1000, a=3141, b = 592, 千分位为1的前缀是‘’”到314，共315次，但是千位数是1，后缀并不都是1000次，只有593次，另外一种情况是后缀是“000”到“592”。所以 <span class="math display">\[(a/10 * 1000)+(b+1)\]</span>。</p>
<p>当前位置是0还是1或者&gt;=2可以用一个公式表达，也就是<span class="math display">\[(a+8)/10\]</span>，最后的部分尾巴用a%10==1判断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ones, m = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> m &lt;= n:</span><br><span class="line">            a, b = n // m, n % m</span><br><span class="line">            ones += (a + <span class="number">8</span>) // <span class="number">10</span> * m + (a % <span class="number">10</span> == <span class="number">1</span>) * (b + <span class="number">1</span>)</span><br><span class="line">            m *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>把数组排成最小的数</p>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<p>排序，怎么排序呢？</p>
<p>如果我们有s1=9, s2=31,排列有s1+s2, s2+s1，本地求最小，当然选拼接起来小的那一种。python3取消了sort的cmp方法,但保留在functools中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums</span></span><br><span class="line">    <span class="comment"># @return &#123;string&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> nums]</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line">        nums.sort(key=cmp_to_key(<span class="keyword">lambda</span> x, y: int(x+y)-int(y+x)))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(nums) <span class="keyword">or</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>第一个只出现一次的字符</p>
<blockquote>
<p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
</blockquote>
<p>判断当前位置得字符s[i]是否在s[:i]+s[i+1:]中。普通做法，256长的数组记录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> s[:i]+s[i+<span class="number">1</span>:]: <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>数组中的逆序对</p>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>题目保证输入的数组中没有的相同的数字数据范围：对于%50的数据,size&lt;=10<sup>4</sup> 对于%75的数据,size&lt;=10<sup>5</sup> 对于%100的数据,size&lt;=2*10<sup>5</sup></p>
<p>示例</p>
<p>输入 : 1,2,3,4,5,6,7,0</p>
<p>输出 : 7</p>
</blockquote>
<p>归并排序。如果是求重要逆序数，记得先不进行归并，先求count，然后再做一遍归并（leetcode 193）。很遗憾，牛客网超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        C = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> j &lt; len(B):</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt;= B[j]:</span><br><span class="line">                C.append(A[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += len(A) - i</span><br><span class="line">                C.append(B[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            C.extend(A[i:])</span><br><span class="line">            C.extend(B[j:])</span><br><span class="line">            <span class="keyword">return</span> count, C</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, nums</span><br><span class="line">        m = len(nums) // <span class="number">2</span></span><br><span class="line">        a, left = self.mergesort(nums[:m])</span><br><span class="line">        b, right = self.mergesort(nums[m:])</span><br><span class="line">        c, res = self.merge(left, right)</span><br><span class="line">        <span class="keyword">return</span> a + b + c, res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        c, _ = self.mergesort(data)</span><br><span class="line">        <span class="keyword">return</span> c % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>两个链表的第一个公共结点</p>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>
<p>笨一点得方法是先求出A, B 连链表得长度（假设A比较长)， 那么A从len(A) - len(B)处开始和B比较，这样两者判断得长度一样。</p>
<p>当然，还有比较巧妙地写法。</p>
<p>p1, p2指针分别指向A, B得head，任一指针到达链表尾，则指向另一链表得头，继续第二轮比较。在第二轮中，他们要么相遇， 要么没有。如果相遇，该点即为所求，如果没有相遇，他们会在同一轮到达链表尾，也就是 p1=p2=None，返回None。（详情见https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49798）</p>
<p>解释：两个指针走的总路程相同，如果有交点，短的指针先走完，然后换到长链表那补全他楼下的路程。如果没有交点，最终都会走向链表尾部。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1, p2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">is</span> <span class="keyword">not</span> p2:</span><br><span class="line">            p1 = p1.next <span class="keyword">if</span> p1 <span class="keyword">else</span> headB</span><br><span class="line">            p2 = p2.next <span class="keyword">if</span> p2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>数字在排序数组中出现的次数</p>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>遍历</p>
<p>二分查找left和right</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        left = bisect.bisect_left(data, k)</span><br><span class="line">        right = bisect.bisect_right(data, k)</span><br><span class="line">        <span class="keyword">return</span> right - left</span><br></pre></td></tr></table></figure>
<p>复习下这两种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></li>
<li><p>二叉树的深度</p>
<blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> max(self.TreeDepth(pRoot.left), self.TreeDepth(pRoot.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>平衡二叉树</p>
<blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<p>借用上题得求深度函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left), self.depth(root.right)) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.depth(root.left) - self.depth(root.right)) &lt; <span class="number">2</span> <span class="keyword">and</span> self.IsBalanced_Solution(root.left) <span class="keyword">and</span> self.IsBalanced_Solution(root.right)</span><br></pre></td></tr></table></figure>
<p>当前，上述解法存在重复计算。我们可以采用后序遍历的方法，判断时就可以知道两边节点的深度。</p>
<p>​</p></li>
<li><p>数组中只出现一次的数字</p>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p>基础版本：一个整型数组里除了一个数字之外，其它的数字都出现了两次。请写程序找出这个只出现一次的数字。</p>
<p>这个比较好做，直接采用异或操作，剩下得就是只出现一次得。</p>
<p>本题是上述得扩展，把数组划分成两部分，每一部分包含一个只出现一次的数字，之后就是异或拉。怎么拆分呢？对所有数组异或，结果肯定不为0，因为有两个只出现一次得数字。在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N位都为1，而第二个子数组的每个数字的第N位都为0。</p>
<p>详情见（http://blog.csdn.net/u011826264/article/details/39269101）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array: n ^= i</span><br><span class="line">        n = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">        j = n.find(<span class="string">'1'</span>)</span><br><span class="line">        a1 = filter(<span class="keyword">lambda</span> x: bin(x)[<span class="number">2</span>:].zfill(len(n))[::<span class="number">-1</span>][j] == <span class="string">'1'</span>, array)</span><br><span class="line">        a2 = filter(<span class="keyword">lambda</span> x: bin(x)[<span class="number">2</span>:].zfill(len(n))[::<span class="number">-1</span>][j] == <span class="string">'0'</span>, array)</span><br><span class="line">        num1, num2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a1: num1 ^= i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a2: num2 ^= i</span><br><span class="line">        <span class="keyword">return</span> [num1, num2]</span><br></pre></td></tr></table></figure>
<p>写完得感受是，python大法好。</p>
<p>​</p></li>
<li><p>和为S的连续正数序列</p>
<blockquote>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<p>输出描述:</p>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
</blockquote>
<p>双指针，大了就h–,小了就l++。l到h得和就用<span class="math display">\[(h+l)*(h-l+1)/2\]</span>表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        l, h = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            cur = (h + l) * ( h - l + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> cur &lt; tsum: h += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur == tsum:</span><br><span class="line">                res.append(list(range(l, h+<span class="number">1</span>)))</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; tsum:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>和为S的两个数字</p>
<blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>输出描述:</p>
<p>对应每个测试案例，输出两个数，小的先输出。</p>
</blockquote>
<p>双指针遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, target)</span>:</span></span><br><span class="line">        n = len(array)</span><br><span class="line">        l, h = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            t = array[l] + array[h]</span><br><span class="line">            <span class="keyword">if</span> t &gt; target:</span><br><span class="line">                h -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> t &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [array[l], array[h]]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>左旋转字符串</p>
<blockquote>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
</blockquote>
<p>字符串截取，用py很好实现，注意取模。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">return</span> s[k%n:]+s[:k%n]</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>翻转单词顺序列</p>
<blockquote>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
</blockquote>
<p>python2 和 python3 有些不一样，牛客网是python2，split函数有些小区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(s.split(<span class="string">' '</span>)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>扑克牌顺子</p>
<blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p>
</blockquote>
<p>必须满足两个条件: 1. 除0外没有重复的数; 2. max - min &lt; 5。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length != <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> number = numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(number &lt; <span class="number">0</span> || number &gt; <span class="number">13</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(number == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(((flag &gt;&gt; number) &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            flag |= (<span class="number">1</span> &lt;&lt; number);</span><br><span class="line">            <span class="keyword">if</span>(number &gt; max) max = number;</span><br><span class="line">            <span class="keyword">if</span>(number &lt; min) min = number;</span><br><span class="line">            <span class="keyword">if</span>(max - min &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>孩子们的游戏(圆圈中最后剩下的数)</p>
<blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
</blockquote>
<p>用数组模拟，但是超时了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> m &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        kids = [<span class="number">1</span>] * n</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> c &lt; m - <span class="number">1</span>:</span><br><span class="line">                j = (j + <span class="number">1</span>) % n</span><br><span class="line">                <span class="keyword">if</span> kids[j]: c += <span class="number">1</span></span><br><span class="line">            kids[j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<p>数学的归纳法：</p>
<p>令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]。</p>
<p>递推公式</p>
<p>f[1]=0;</p>
<p>f[i]=(f[i-1]+m)%i; (i&gt;1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> m &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            s = (s + m) % i</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>求1+2+3+…+n</p>
<blockquote>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</blockquote>
<p><span class="math display">\[\frac{n^2+n}{2}\]</span> , 用乘方、加、右移实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (n ** <span class="number">2</span> + n) &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>把字符串转换成整数</p>
<blockquote>
<p>题目描述</p>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<p>输入描述:</p>
<p>输入一个字符串,包括数字字母符号,可以为空</p>
<p>输出描述:</p>
<p>如果是合法的数值表达则返回该数字，否则返回0</p>
<p>示例1</p>
<p>输入 +2147483647 1a33</p>
<p>输出 2147483647 0</p>
</blockquote>
<p>遍历，遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        res, base, i = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        flag = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">'+-'</span>: i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>: flag = <span class="keyword">False</span></span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= i:</span><br><span class="line">            <span class="keyword">if</span> s[j].isdigit():</span><br><span class="line">                res += (ord(s[j]) - ord(<span class="string">'0'</span>)) * base</span><br><span class="line">                base *= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> flag <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>数组中重复的数字</p>
<blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>判断i是否在n[:i]之中就行，但是python怎么也过不了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] <span class="keyword">in</span> numbers[:i]:</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>java可以过的版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] k = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k[numbers[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k[numbers[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​空间复杂度为O(1)的解法是，交换，如果当前位置的数和序号相等，则继续，若不等，比较当前数和他该待着的位置的数比较，如果相等，那么我们找到一个重复的，不等则swap，继续比较。</p></li>
<li><p>构建乘积数组</p>
<blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
</blockquote>
<p>left保持左侧连乘，right保存右侧起的连乘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        left, right = [<span class="number">1</span>], [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            left.append(left[<span class="number">-1</span>] * i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A[::<span class="number">-1</span>]:</span><br><span class="line">            right.append(right[<span class="number">-1</span>] * i)</span><br><span class="line">        B = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            B.append(left[i] * right[<span class="number">-2</span>-i])</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>正则表达式匹配</p>
<blockquote>
<p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>’表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串“aaa”与模式“a.a”和“ab<em>ac</em>a”匹配，但是与“aa.a”和“ab*a“均不匹配</p>
</blockquote>
<p>动态规划拉。</p>
<p>This problem has a typical solution using Dynamic Programming. We define the state <code>P[i][j]</code> to be <code>true</code> if <code>s[0..i)</code> matches <code>p[0..j)</code> and <code>false</code> otherwise. Then the state equations are:</p>
<ol type="1">
<li><code>P[i][j] = P[i - 1][j - 1]</code>, if <code>p[j - 1] != '*' &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')</code>;</li>
<li><code>P[i][j] = P[i][j - 2]</code>, if <code>p[j - 1] == '*'</code> and the pattern repeats for <code>0</code> times;</li>
<li><code>P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.')</code>, if <code>p[j - 1] == '*'</code> and the pattern repeats for at least <code>1</code> times.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] <span class="keyword">or</span> (</span><br><span class="line">                            i &gt; <span class="number">0</span> <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">'.'</span>) <span class="keyword">and</span> dp[i - <span class="number">1</span>][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> <span class="keyword">and</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>表示数值的字符串</p>
<blockquote>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”,“5e2”,“-123”,“3.1416”和“-1E-16”都表示数值。 但是“12e”,“1a3.14”,“1.2.3”,“+-5”和“12e+4.3”都不是。</p>
</blockquote>
<p>正则表达式比较简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> re.match(<span class="string">r"^[+-]?[0-9]*(\.[0-9]*)?([eE][+-]?[0-9]+)?$"</span>, s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>字符流中第一个不重复的字符</p>
<blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符“go”时，第一个只出现一次的字符是“g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是“l”。</p>
<p>输出描述:</p>
<p>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
</blockquote>
<p>用一个队列（保证输出第一个出现一次的字符）和数组（anscii码256）实现，每次insert时候判断当前字符的次数，如果只出现一次，插入到队列中，输出时要再判断一下该字符是否只出现一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">        self.q = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.q <span class="keyword">and</span> self.s[ord(self.q[<span class="number">0</span>])] &gt; <span class="number">1</span>: self.q.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.q: <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        self.s[ord(c)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.s[ord(c)] == <span class="number">1</span>:</span><br><span class="line">            self.q.append(c)</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>链表中环的入口结点</p>
<blockquote>
<p>一个链表中包含环，请找出该链表的环的入口结点。</p>
</blockquote>
<p>快慢指针发现是否有环（leetcode 141）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        p1, p2 = head, head</span><br><span class="line">        <span class="keyword">while</span> p1.next <span class="keyword">and</span> p2.next <span class="keyword">and</span> p2.next.next:</span><br><span class="line">            p1, p2 = p1.next, p2.next.next</span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnitblog.com/blog/528669/201407/230518072134822.png"></p>
<p>从链表起始处到环入口长度为：a，从环入口到Faster和Slower相遇点长度为：x，整个环长为：c。</p>
<p>假设从开始到相遇，Slower走过的路程长为s，由于Faster的步速是Slower的2倍，那么Faster在这段时间走的路程长为2s。</p>
<p>而对于Faster来说，他走的路程还等于之前绕整个环跑的n圈的路程nc，加上最后这一次遇见Slower的路程s。</p>
<p>所以我们有：</p>
<p>​ 2s = nc + s</p>
<p>对于Slower来说，他走的路程长度s还等于他从链表起始处到相遇点的距离，所以有：</p>
<p>​ s = a + x</p>
<p>通过以上两个式子代入化简有：</p>
<p>​ a + x = nc</p>
<p>​ a = nc - x</p>
<p>​ a = (n-1)c + c-x</p>
<p>​ a = kc + (c-x)</p>
<p>那么可以看出，c-x，就是从相遇点继续走回到环入口的距离。上面整个式子可以看出，如果此时有个pointer1从起始点出发并且同时还有个pointer2从相遇点出发继续往前走（都只迈一步），那么绕过k圈以后， pointer2会和pointer1在环入口相遇。这样，换入口就找到了。(摘自https://www.cnblogs.com/springfor/p/3862125.html)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1, p2 = head, head</span><br><span class="line">        hasCycle = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> p1.next <span class="keyword">and</span> p2.next <span class="keyword">and</span> p2.next.next:</span><br><span class="line">            p1, p2 = p1.next, p2.next.next</span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                hasCycle = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasCycle: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p2 = head</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1, p2 = p1.next, p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>删除链表中重复的结点</p>
<blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
</blockquote>
<p>重复的保留一个(leetcode 83)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            pos = cur.next</span><br><span class="line">            <span class="keyword">if</span> pos.val == cur.val:</span><br><span class="line">                cur.next = pos.next</span><br><span class="line">                <span class="keyword">del</span> pos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = pos</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>一个不留的(leetcode 82)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        dump = ListNode(<span class="number">0</span>)</span><br><span class="line">        pre, dump.next, cur = dump, head, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.next.val == cur.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> pre.next == cur:  <span class="comment"># 说明不重复，没有删除元素</span></span><br><span class="line">                pre = pre.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dump.next</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>二叉树的下一个结点</p>
<blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>分析二叉树的下一个节点，一共有以下情况：</p>
<p>1.二叉树为空，则返回空；</p>
<p>2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；</p>
<p>3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p>
<figure>
<img src="/images/剑指offer_55.png" alt="55"><figcaption>55</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            root = root.right</span><br><span class="line">            <span class="keyword">while</span> root.left:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">while</span> root.next:</span><br><span class="line">            p = root.next</span><br><span class="line">            <span class="keyword">if</span> p.left == root: <span class="keyword">return</span> p</span><br><span class="line">            root = root.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>对称的二叉树</p>
<blockquote>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<p>一开始想得是层次遍历，然后判断每层是否对称，后来发现不对，因为，如如果某一层是 4 # 2 4，满足要求但不是对称得。</p>
<p>其实就是dfs啊。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left == right</span><br><span class="line">            <span class="keyword">return</span> left.val == right.val <span class="keyword">and</span> check(left.left, right.right) <span class="keyword">and</span> check(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> root <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> check(root.left, root.right)</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>按之字形顺序打印二叉树</p>
<blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<p>层次遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        flag = <span class="keyword">True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp, tmpval = [], []</span><br><span class="line">            i = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i: tmpval.append(p.val)</span><br><span class="line">                <span class="keyword">else</span>: tmpval.insert(<span class="number">0</span>, p.val)</span><br><span class="line">                <span class="keyword">if</span> p.left: tmp.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right: tmp.append(p.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">            res.append(tmpval)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>我以前leetcode上的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        queue, res = collections.deque([(root, <span class="number">0</span>)]), []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, level = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> len(res) &lt; level + <span class="number">1</span>:</span><br><span class="line">                    res.insert(level, [])</span><br><span class="line">                <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    res[level].append(node.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[level].insert(<span class="number">0</span>, node.val)</span><br><span class="line">                queue.append((node.left, level + <span class="number">1</span>))</span><br><span class="line">                queue.append((node.right, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>把二叉树打印成多行</p>
<blockquote>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<p>层次遍历。我的习惯性做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp, tmpval = [], []</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                tmpval.append(p.val)</span><br><span class="line">                <span class="keyword">if</span> p.left: tmp.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right: tmp.append(p.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">            res.append(tmpval)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>当然，可以改进下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            n = len(queue)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> queue:</span><br><span class="line">                tmp.append(p.val)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> p.left: queue.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right: queue.append(p.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>序列化二叉树</p>
<blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
</blockquote>
<p>先序遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">doit</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                vals.append(str(node.val))</span><br><span class="line">                doit(node.left)</span><br><span class="line">                doit(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vals.append(<span class="string">'#'</span>)</span><br><span class="line">        vals = []</span><br><span class="line">        doit(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(vals)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">doit</span><span class="params">()</span>:</span></span><br><span class="line">            val = next(vals)</span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">'#'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            node = TreeNode(int(val))</span><br><span class="line">            node.left = doit()</span><br><span class="line">            node.right = doit()</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        vals = iter(data.split())</span><br><span class="line">        <span class="keyword">return</span> doit()</span><br></pre></td></tr></table></figure></li>
<li><p>二叉搜索树的第k个结点</p>
<blockquote>
<p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 /  3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
</blockquote>
<p>中序遍历吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            dfs(root.left, res)</span><br><span class="line">            res.append(root)</span><br><span class="line">            dfs(root.right, res)</span><br><span class="line"></span><br><span class="line">        dfs(root, res)</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>] <span class="keyword">if</span> k &lt;= len(res) <span class="keyword">else</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>改进下，这个递归有点难懂，在到达k个节点之前是不会返回的，到达k时返回return root, 上层的就继续返回return left or return right：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            left = self.KthNode(root.left, k)</span><br><span class="line">            <span class="keyword">if</span> left: <span class="keyword">return</span> left</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.count == k: <span class="keyword">return</span> root</span><br><span class="line">            right = self.KthNode(root.right, k)</span><br><span class="line">            <span class="keyword">if</span> right: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>数据流中的中位数</p>
<blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
</blockquote>
<p>解题思路就是用两个堆，一个大顶堆，一个小顶堆来过滤数据。大顶堆代表排序后得左边数据，小顶堆代表右半边数据。维持这一特性即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.maxheap = []</span><br><span class="line">        self.minheap = []</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            heapq.heappush(self.maxheap, -num)</span><br><span class="line">            tmp = -heapq.heappop(self.maxheap)</span><br><span class="line">            heapq.heappush(self.minheap, tmp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.minheap, num)</span><br><span class="line">            tmp = -heapq.heappop(self.minheap)</span><br><span class="line">            heapq.heappush(self.maxheap, tmp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (-self.maxheap[<span class="number">0</span>] + self.minheap[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -self.maxheap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>还是牛客网过不了，奇怪得报错。</p>
<p>牛客网的一个写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">  <span class="function">pulic <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(p.empty() || num &lt;= p.top()) p.push(num);</span><br><span class="line">      <span class="keyword">else</span> q.push(num);</span><br><span class="line">      <span class="keyword">if</span>(p.size() == q.size() + <span class="number">2</span>) q.push(p.top()), p.pop();</span><br><span class="line">      <span class="keyword">if</span>(p.size() + <span class="number">1</span> == q.size()) p.push(q.top()), q.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p.size() == q.size() ? (p.top() + q.top()) / <span class="number">2.0</span> : p.top();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            v.push_back(num);</span><br><span class="line">            n = v.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; v[i] &lt; v[i - <span class="number">1</span>]; --i) swap(v[i], v[i - <span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span>&#123; </span><br><span class="line">          <span class="keyword">return</span> (v[(n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>] + v[n &gt;&gt; <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li><p>滑动窗口的最大值</p>
<blockquote>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
</blockquote>
<p>我的想法简单，维持滑动窗口得最大值，就三种情况，最大值在当前位置，在上一窗口和当前窗口重叠得部分，上一轮最大值被抛弃。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">1</span> <span class="keyword">or</span> size &gt; len(num): <span class="keyword">return</span> []</span><br><span class="line">        _max = max(num[:size])</span><br><span class="line">        res = [_max]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size, len(num)):</span><br><span class="line">            <span class="keyword">if</span> num[i] &gt; num[i - size]:</span><br><span class="line">                _max = max(_max, num[i])</span><br><span class="line">            <span class="keyword">elif</span> _max == num[i - size]:</span><br><span class="line">                _max = max(num[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">            res.append(_max)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>感觉牛客网上推荐得答案也不是太好，话不如直接max函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">用一个双端队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次</span></span><br><span class="line"><span class="comment">1.判断当前最大值是否过期</span></span><br><span class="line"><span class="comment">2.新增加的值从队尾开始比较，把所有比他小的值丢掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> begin; </span><br><span class="line">        ArrayDeque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)&#123;</span><br><span class="line">            begin = i - size + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q.isEmpty())</span><br><span class="line">                q.add(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(begin &gt; q.peekFirst())</span><br><span class="line">                q.pollFirst();</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">while</span>((!q.isEmpty()) &amp;&amp; num[q.peekLast()] &lt;= num[i])</span><br><span class="line">                q.pollLast();</span><br><span class="line">            q.add(i);  </span><br><span class="line">            <span class="keyword">if</span>(begin &gt;= <span class="number">0</span>)</span><br><span class="line">                res.add(num[q.peekFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>矩阵中的路径</p>
<blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串“bcced”的路径，但是矩阵中不包含“abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
</blockquote>
<p>dfs</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        visit = [<span class="keyword">False</span>] * (cols *rows)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(matrix, rows, cols, path, visit, i, j, k)</span>:</span></span><br><span class="line">            index = i * cols + j</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= rows <span class="keyword">or</span> j &gt;= cols <span class="keyword">or</span> visit[index] <span class="keyword">or</span> matrix[index] != path[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> k == len(path) - <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            visit[index] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> dfs(matrix, rows, cols, path, visit, i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    dfs(matrix, rows, cols, path, visit, i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    dfs(matrix, rows, cols, path, visit, i, j - <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    dfs(matrix, rows, cols, path, visit, i, j + <span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            visit[index] = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> dfs(matrix, rows, cols, path, visit, i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>​</p></li>
<li><p>机器人的运动范围</p>
<blockquote>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<p>dfs拉，改改上一题得就行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        visit = [[<span class="keyword">False</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> range(rows)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(rows, cols, visit, i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= rows <span class="keyword">or</span> j &gt;= cols <span class="keyword">or</span> visit[i][j] <span class="keyword">or</span> \</span><br><span class="line">                    sum(map(int, [i <span class="keyword">for</span> i <span class="keyword">in</span> str(i) + str(j)])) &gt; k:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visit[i][j] = <span class="keyword">True</span></span><br><span class="line">            dfs(rows, cols, visit, i - <span class="number">1</span>, j, k)</span><br><span class="line">            dfs(rows, cols, visit, i + <span class="number">1</span>, j, k)</span><br><span class="line">            dfs(rows, cols, visit, i, j - <span class="number">1</span>, k)</span><br><span class="line">            dfs(rows, cols, visit, i, j + <span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                dfs(rows, cols, visit, i, j, threshold)</span><br><span class="line">        <span class="keyword">return</span> sum([sum(i) <span class="keyword">for</span> i <span class="keyword">in</span> visit])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>结论：</p>
<p>​ 刷到最后20道左右时，就有些浮躁，想不出题解就直接看我leetcode上的solution了，尴尬，刷题还是不能浮躁，得沉住气。</p>
<p>​ 并且，刷完发现少了2道题，这，懒得找了，哈哈。</p>
<p>​ 当然，我的所有代码都是python3写的，有的在牛客网网通过不了，因为牛客网只支持python2。by，全文中得其他语言所写代码几乎是网上借鉴得写法。</p>
<p>​ 2018.1.5 中科院软件所</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-04-11T09:11:03.040Z" itemprop="dateUpdated">2018-04-11 17:11:03</time>
</span><br>


        
        本文链接：<a href="/2017/12/22/剑指offer题解/" target="_blank" rel="external">http://wuqiansheng.xyz/2017/12/22/剑指offer题解/</a>
        
    </div>
    
    <footer>
        <a href="http://wuqiansheng.xyz">
            <img src="http://7xso5r.com1.z0.glb.clouddn.com/avstar.jpg" alt="wqs">
            wqs
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/剑指Offer/">剑指Offer</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/&title=《牛客网《剑指Offer》66题 题解》 — wuqiansheng&pic=http://7xso5r.com1.z0.glb.clouddn.com/avstar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/&title=《牛客网《剑指Offer》66题 题解》 — wuqiansheng&source=
字符串的排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串ab..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《牛客网《剑指Offer》66题 题解》 — wuqiansheng&url=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/&via=http://wuqiansheng.xyz" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/04/02/LightGBM原理之论文详解/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">LightGBM原理之论文详解</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/04/03/Tensorflow-Solve-Mnist-2/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Tensorflow Solve Mnist 2</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'wqs';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>
















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢支持~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="http://7xso5r.com1.z0.glb.clouddn.com/weixin.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="http://7xso5r.com1.z0.glb.clouddn.com/weixin.png" data-alipay="http://7xso5r.com1.z0.glb.clouddn.com/zhifubao.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>wqs &copy; 2015 - 2018</span>
            <span>
                
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/&title=《牛客网《剑指Offer》66题 题解》 — wuqiansheng&pic=http://7xso5r.com1.z0.glb.clouddn.com/avstar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/&title=《牛客网《剑指Offer》66题 题解》 — wuqiansheng&source=
字符串的排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串ab..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《牛客网《剑指Offer》66题 题解》 — wuqiansheng&url=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/&via=http://wuqiansheng.xyz" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://wuqiansheng.xyz/2017/12/22/剑指offer题解/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '一路走好！';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎再来!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/"});</script></body>
</html>
