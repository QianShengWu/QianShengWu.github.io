<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wuqiansheng</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wuqiansheng.xyz/"/>
  <updated>2018-04-06T11:10:39.906Z</updated>
  <id>http://wuqiansheng.xyz/</id>
  
  <author>
    <name>wqs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LightGBM原理之论文详解</title>
    <link href="http://wuqiansheng.xyz/2018/04/02/LightGBM%E5%8E%9F%E7%90%86%E4%B9%8B%E8%AE%BA%E6%96%87%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wuqiansheng.xyz/2018/04/02/LightGBM原理之论文详解/</id>
    <published>2018-04-02T07:14:09.000Z</published>
    <updated>2018-04-06T11:10:39.906Z</updated>
    
    <content type="html"><![CDATA[<p>提升树是利用加模型与前向分布算法实现学习的优化过程，它有一些高效实现，如XGBoost, pGBRT，GBDT等。其中GBDT采用负梯度作为划分的指标（信息增益），XGBoost则利用到二阶导数。他们共同的不足是，计算信息增益需要扫描所有样本，从而找到最优划分点。在面对大量数据或者特征维度很高时，他们的效率和扩展性很难使人满意。微软开源的LightGBM（基于GBDT的）则很好的解决这些问题，它主要包含两个算法：</p><ol type="1"><li>GOSS（从减少样本角度）：排除大部分小梯度的样本，仅用剩下的样本计算信息增益。</li><li>EFB（从减少特征角度）：捆绑互斥特征，也就是他们很少同时取非零值（也就是用一个合成特征代替）。</li></ol><p>前言：</p><p>GBDT是基于决策树的集成算法，采用前向分布算法，在每次迭代中，都是通过负梯度拟合残差，从而学习一颗决策树，最耗时的步骤就是找最优划分点。一种流行的方法就是预排序，核心是在已经排好序的特征值上枚举所有可能的特征点。另一种改进则是直方图算法，他把连续特征值划分到k个桶中取，划分点则在这k个点中选取。k&lt;&lt;d，所以在内存消耗和训练速度都更佳，且在实际的数据集上表明，离散化的分裂点对最终的精度影响并不大，甚至会好一些。原因在于决策树本身就是一个弱学习器，采用Histogram算法会起到正则化的效果，有效地防止模型的过拟合。LightGBM也是基于直方图的。</p><p>为了减少训练数据，最直接的方法就是欠采样(down sample)，比如说过滤掉权重低于阈值的样本。SGB(随机梯度下降)采用的是在每轮迭代中选取随机子集进行训练弱分类器，AdaBoost则采用的是动态调整采样率。SGB可以应用到GBDT，但会影响精度，其他的则不能直接引入，因为GBDT中没有这种内在的权重。</p><p>为了减少特征，通常做的是PCA降维，但是这些方法都假设特征是冗余的，这并不一直正确。</p><p>一般大型数据集都是稀疏的，基于pre-sorted的GBDT可以通过忽略零值特征，从而减少训练代价。但是，基于histogram的则没有针对稀疏特性的优化方案，它只是计算累加值，不管你是0还是非0。所以，利用稀疏性的GBDT是很必要的。</p><p>接下来就要细细说说这两个算法。</p><a id="more"></a><h4 id="goss">GOSS</h4><p>在AdaBoost中采用权重很好诠释了样本的重要性，GBDT没有这种权重，但是我们注意到每个数据样本的梯度可以被用来做采样的信息。也就是，如果一个样本的梯度小，那么表明这个样本已经训练好了，它的训练误差很小了，我们可以丢弃这些数据。当然，改变数据分布会造成模型的精度损失。GOSS则通过保存大梯度样本，随机选取小梯度样本，并为其弥补上一个常数权重。这样，GOSS更关注训练不足的样本，同时也不会改变原始数据太多。</p><p>具体算法如下： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/LightGBM/GOSS.png" alt="GOSS" title="">                </div>                <div class="image-caption">GOSS</div>            </figure></p><p>先根据梯度对样本进行排序，选取 a * 100% 的top样本，再从剩余数据中随机选取 b * 100% 的样本，并乘以 <span class="math display">\[\frac{1-a}{b}\]</span>的系数放大。</p><p>以前计算特征j在d值点的信息增益是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/LightGBM/3.1.png" alt="3.1" title="">                </div>                <div class="image-caption">3.1</div>            </figure><p>现在是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/LightGBM/3.2.png" alt="3.2" title="">                </div>                <div class="image-caption">3.2</div>            </figure><p>通过证明，近似误差很好，很贴近使用所有数据的模型。</p><p>这也解释了LightGBM的 leaf-wise 生成策略。</p><h5 id="leaf-wise-best-first-的决策树生长策略">Leaf-wise (Best-first) 的决策树生长策略</h5><p>大部分决策树的学习算法通过 level(depth)-wise 策略生长树，如下图一样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lightgbm.apachecn.org/cn/latest/_images/level-wise.png" alt="_images/level-wise.png" title="">                </div>                <div class="image-caption">_images/level-wise.png</div>            </figure><p>LightGBM 通过 leaf-wise (best-first)[<a href="http://lightgbm.apachecn.org/cn/latest/Features.html#references" target="_blank" rel="noopener">6]</a> 策略来生长树。它将选取具有最大 delta loss 的叶节点来生长。 当生长相同的 <code>#leaf</code>，leaf-wise 算法可以比 level-wise 算法减少更多的损失。</p><p>当 <code>#data</code> 较小的时候，leaf-wise 可能会造成过拟合。 所以，LightGBM 可以利用额外的参数 <code>max_depth</code> 来限制树的深度并避免过拟合（树的生长仍然通过 leaf-wise 策略）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lightgbm.apachecn.org/cn/latest/_images/leaf-wise.png" alt="_images/leaf-wise.png" title="">                </div>                <div class="image-caption">_images/leaf-wise.png</div>            </figure><p>####EFB</p><p>高维数据一般是稀疏的，可以设计一种损失最小的特征减少方法。并且，在稀疏特征空间中，许多特征都是互斥的，也就是它们几乎不同时取非0值。因此，我们可以安全的把这些互斥特征绑到一起形成一个特征，然后基于这些特征束构建直方图，这样又可以加速了。</p><p>有两个问题待解决，如何判断哪些特征该绑到一起，如何构建绑定。这是NP难的。</p><p>首先，转换到图着色问题。G=(V, E)，把关联矩阵G的每一行看成特征，从而得到|V|个特征，互斥束就图中颜色相同的顶点。图中点就是特征，边代表两个特征不互斥，也就是特征之间的冲突。如果算法允许小的冲突，可以得到更小的特征束数量，计算效率会更高。证明发现随机污染一小部分特征值，最多影响训练精度 <span class="math display">\[O([(1-\gamma)n]^{-2/3})\]</span>，<span class="math display">\[\gamma\]</span>是所有束中冲突最大的。通过选取合适的<span class="math display">\[\gamma\]</span>，我们可以很好的在效率和精度之间寻找平衡。</p><p>不互斥 =&gt; 可以同时取非0值，不能区分处理 =&gt; 冲突</p><p>最后，排序就按照束的度来进行。当然，更一步优化是不够造图，直接<strong>根据非零值的数量排序</strong>，这个根据度排序很像，因为更多非0值意味着更高概率的冲突。更改了排序策略，可以避免重复。</p><p>第二个问题，合并特征，从而降低训练复杂度，关键是我们可以确保原先特征值可以从特征束中识别出来。因为直方图存储的是特征的离散桶，而不是连续值，我们可以通过把互斥特征放到不同桶，从而构造一个特征束。这可以通过添加偏移实现。如，假设我们有2个特征在一个特征束中，原先特征A的范围为[0,10)，特征B的范围为[0,20)，我们给特征B加上一个偏移10，它就变成[10,30)，这样我们就可以执行安全的合并了，用特征束[0,30)代替特征A和B。具体算法如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/LightGBM/4.png" alt="4" title="">                </div>                <div class="image-caption">4</div>            </figure><p>EFB算法可以把很多特征绑到一起，形成更少的稠密特征束，这样可以避免对0特征值的无用的计算。加速计算直方图还可以用一个表记录数据的非0值。</p><p>这样，LightGBM的论文基本讲解结束。</p><p>其他具体特性（并行，类别特征处理等）详情见：</p><p>http://lightgbm.apachecn.org/cn/latest/Features.html</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提升树是利用加模型与前向分布算法实现学习的优化过程，它有一些高效实现，如XGBoost, pGBRT，GBDT等。其中GBDT采用负梯度作为划分的指标（信息增益），XGBoost则利用到二阶导数。他们共同的不足是，计算信息增益需要扫描所有样本，从而找到最优划分点。在面对大量数据或者特征维度很高时，他们的效率和扩展性很难使人满意。微软开源的LightGBM（基于GBDT的）则很好的解决这些问题，它主要包含两个算法：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;GOSS（从减少样本角度）：排除大部分小梯度的样本，仅用剩下的样本计算信息增益。&lt;/li&gt;
&lt;li&gt;EFB（从减少特征角度）：捆绑互斥特征，也就是他们很少同时取非零值（也就是用一个合成特征代替）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;GBDT是基于决策树的集成算法，采用前向分布算法，在每次迭代中，都是通过负梯度拟合残差，从而学习一颗决策树，最耗时的步骤就是找最优划分点。一种流行的方法就是预排序，核心是在已经排好序的特征值上枚举所有可能的特征点。另一种改进则是直方图算法，他把连续特征值划分到k个桶中取，划分点则在这k个点中选取。k&amp;lt;&amp;lt;d，所以在内存消耗和训练速度都更佳，且在实际的数据集上表明，离散化的分裂点对最终的精度影响并不大，甚至会好一些。原因在于决策树本身就是一个弱学习器，采用Histogram算法会起到正则化的效果，有效地防止模型的过拟合。LightGBM也是基于直方图的。&lt;/p&gt;
&lt;p&gt;为了减少训练数据，最直接的方法就是欠采样(down sample)，比如说过滤掉权重低于阈值的样本。SGB(随机梯度下降)采用的是在每轮迭代中选取随机子集进行训练弱分类器，AdaBoost则采用的是动态调整采样率。SGB可以应用到GBDT，但会影响精度，其他的则不能直接引入，因为GBDT中没有这种内在的权重。&lt;/p&gt;
&lt;p&gt;为了减少特征，通常做的是PCA降维，但是这些方法都假设特征是冗余的，这并不一直正确。&lt;/p&gt;
&lt;p&gt;一般大型数据集都是稀疏的，基于pre-sorted的GBDT可以通过忽略零值特征，从而减少训练代价。但是，基于histogram的则没有针对稀疏特性的优化方案，它只是计算累加值，不管你是0还是非0。所以，利用稀疏性的GBDT是很必要的。&lt;/p&gt;
&lt;p&gt;接下来就要细细说说这两个算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LightGBM" scheme="http://wuqiansheng.xyz/tags/LightGBM/"/>
    
      <category term="GBDT" scheme="http://wuqiansheng.xyz/tags/GBDT/"/>
    
      <category term="GOSS" scheme="http://wuqiansheng.xyz/tags/GOSS/"/>
    
      <category term="EFB" scheme="http://wuqiansheng.xyz/tags/EFB/"/>
    
  </entry>
  
  <entry>
    <title>牛客网《剑指Offer》66题 题解</title>
    <link href="http://wuqiansheng.xyz/2017/12/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    <id>http://wuqiansheng.xyz/2017/12/22/剑指offer题解/</id>
    <published>2017-12-22T11:12:11.000Z</published>
    <updated>2018-04-06T13:17:56.595Z</updated>
    
    <content type="html"><![CDATA[<ol type="1"><li><p>字符串的排列</p><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p>输入描述:</p><p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p></blockquote><p>dfs， 但是牛客网有些尴尬，list的顺序还得保障，所以结果得sort一下。为了防止重复，用了set。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss: <span class="keyword">return</span> []</span><br><span class="line">        res = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(res, ss, s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss: res.add(s)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                s = s + ss[i]</span><br><span class="line">                dfs(res, ss[:i] + ss[i + <span class="number">1</span>:], s)</span><br><span class="line">                s = s[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        dfs(res, ss, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> sorted(list(res))</span><br></pre></td></tr></table></figure><p>当然，这只是简单得写法。高级得用swap实现，详情见STL中得permutation经典算法。</p></li></ol><a id="more"></a><p>​</p><ol start="2" type="1"><li><p>链表中倒数第k个结点</p><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><p>先求链表长度n，然后输出第n-k节点。注意k&gt;n的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">if</span> k &gt; n: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        t = n - k</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(t):</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure></li><li><p>跳台阶</p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p><span class="math display">\[f(n)=f(n-1)+f(n-2), f(0)=f(1)=1\]</span>，斐波那契数列的变体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(number):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></li><li><p>变态跳台阶</p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>数学推导：<span class="math display">\[f(n)=f(n-1)+f(n-2)+...+f(1)\]</span>，<span class="math display">\[f(n-1)=f(n-2)+f(n-3)+...+f(1)\]</span></p><p><span class="math display">\[f(1)=1\]</span>，因而有<span class="math display">\[f(n)=2f(n-1)=2^{n-1}\]</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> ** (number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>不用加减乘除做加法</p><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></blockquote><p>也就是用二进制的加法，二进制位相加用异或，进位用与并左移一位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            tmp = num1 ^ num2;</span><br><span class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述的实现有些技巧，主要利用c++整数逸出会变0解决<span class="math display">\[-1+1=0\]</span>的情况，而python则没有逸出的概念，所以我们要与上0xffffffff。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: int</span></span><br><span class="line"><span class="string">        :type b: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 32 bits integer max</span></span><br><span class="line">        MAX = <span class="number">0x7FFFFFFF</span></span><br><span class="line">        <span class="comment"># 32 bits interger min</span></span><br><span class="line">        MIN = <span class="number">0x80000000</span></span><br><span class="line">        <span class="comment"># mask to get last 32 bits</span></span><br><span class="line">        mask = <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry</span></span><br><span class="line">            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; <span class="number">1</span>) &amp; mask</span><br><span class="line">        <span class="comment"># if a is negative, get a's 32 bits complement positive first</span></span><br><span class="line">        <span class="comment"># then get 32-bit positive's Python complement negative</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= MAX <span class="keyword">else</span> ~(a ^ mask)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>替换空格</p><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">import</span> re</span><br><span class="line">        s = re.sub(<span class="string">' '</span>, <span class="string">'%20'</span>, s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>顺序针打印矩阵</p><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> matrix <span class="keyword">and</span> list(matrix.pop(<span class="number">0</span>)) + self.printMatrix(list(zip(*matrix))[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>二维数组中的查找</p><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>类似二叉搜索树，从右上角开始依次左、下遍历，或者从左下角开始依次上、右遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        m, n = len(array), len(array[<span class="number">0</span>])</span><br><span class="line">        i, j = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[i][j] == target: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> array[i][j] &lt; target: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>包含min函数的栈</p><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p></blockquote><p>同时维护一个最小栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minstack = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minstack:</span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        <span class="keyword">elif</span> node &lt; self.minstack[<span class="number">-1</span>]:</span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minstack.append(self.minstack[<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.minstack.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>重建二叉树</p></li></ol><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> inorder:</span><br><span class="line">            id = inorder.index(preorder.pop(<span class="number">0</span>))</span><br><span class="line">            root = TreeNode(inorder[id])</span><br><span class="line">            root.left = self.reConstructBinaryTree(preorder, inorder[:id])</span><br><span class="line">            root.right = self.reConstructBinaryTree(preorder, inorder[id+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><p>​</p><ol start="11" type="1"><li><p>用两个栈实现队列</p><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><p>一个in栈，一个out栈，in栈用于直接push，out栈用于逆向pop in 栈中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.instack = []</span><br><span class="line">        self.outstack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.instack.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.outstack:</span><br><span class="line">            <span class="keyword">while</span> self.instack:</span><br><span class="line">                self.outstack.append(self.instack.pop())</span><br><span class="line">        <span class="keyword">return</span> self.outstack.pop()</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>旋转数组的最小数字</p><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p>二分查找的变体，采用左闭右开的写法，维持l是最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, h = <span class="number">0</span>, len(rotateArray) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            m = (l + h) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[m] &gt; rotateArray[h]:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = m</span><br><span class="line">        <span class="keyword">return</span> rotateArray[l]</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>斐波那契数列</p><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。</p><p>n&lt;=39</p></blockquote><p>用a, b 两个变量记录前后两个斐波那契数，c记录第几个。(注意n=0, 0)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> c &lt; n:</span><br><span class="line">            b, a, c = a, a + b, c + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>矩阵覆盖</p><blockquote><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p></blockquote><p>还是斐波那契的变体形式，不想写递推了，直接递归实现。不过python会超时，所以改用java拉。</p><p><img src="https://uploadfiles.nowcoder.com/images/20160616/716804_1466088939214_DB8DE8E90C58DADF4C1048A7B110E8E5"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二进制中1的个数</p><blockquote><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p></blockquote><p>先求出二进制，然后不同向右移位，统计最低位为1的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([(n &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>)])</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>数值的整数次方</p><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> base ** exponent</span><br></pre></td></tr></table></figure><p>当然有高深的解法，也就是==&gt;快速幂.(https://www.cnblogs.com/CXCXCXC/p/4641812.html)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> exponent:</span><br><span class="line">            <span class="keyword">if</span> exponent &amp; <span class="number">1</span>: ans *= base</span><br><span class="line">            base *= base</span><br><span class="line">            exponent &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>这种再牛客网上提交会超时，毕竟python，时间限制的严。但是这确实是O(log n)的解法。</p><p>主要思想是分解exponent，如base=a, exponent=11, <span class="math display">\[11=2^3+2^1+2^0=1011\]</span>，也就是说 <span class="math display">\[a^{11}=a^{2^0+2^1+2^3}=a^*a^*a^\]</span> 也就是不停判断exponent的最低一位，a则不停翻倍，实现a=&gt;a<sup>2</sup>=&gt;a<sup>3</sup> ，如果b的最低位是1就乘上去呗。</p></li><li><p>调整数组顺序使奇数位于偶数前面</p><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></blockquote><p>类似冒泡算法，前偶后奇数就交换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        n = len(array)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> array[j] &amp; <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> array[j - <span class="number">1</span>] &amp; <span class="number">1</span>:</span><br><span class="line">                    array[j], array[j<span class="number">-1</span>] = array[j<span class="number">-1</span>], array[j]</span><br></pre></td></tr></table></figure><p>当然最简单的还是耗空间的解法，遍历楼。</p><p>​</p></li><li><p>反转链表</p><blockquote><p>输入一个链表，反转链表后，输出链表的所有元素。</p></blockquote><p>链表经典题型拉。三个指针拉，pre, cur, pos。cur.next = pre是关键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            pos = pHead.next</span><br><span class="line">            pHead.next = pre</span><br><span class="line">            pre = pHead</span><br><span class="line">            pHead = pos</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></li><li><p>合并两个排序的链表</p><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><p>归并排序呗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        L = ListNode(<span class="number">0</span>)</span><br><span class="line">        p, p1, p2 = L, pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt;= p2.val:</span><br><span class="line">                p.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">if</span> p1: p.next = p1</span><br><span class="line">        <span class="keyword">if</span> p2: p.next = p2</span><br><span class="line">        <span class="keyword">return</span> L.next</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>树的子结构</p><blockquote><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p></blockquote><p>递归查找呗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot2 <span class="keyword">or</span> <span class="keyword">not</span> pRoot1: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.isSame(pRoot1, pRoot2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSame</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">and</span> p2: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> p1.val != p2.val: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSame(p1.left, p2.left) <span class="keyword">and</span> self.isSame(p1.right, p2.right)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>二叉树的镜像</p><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义：源二叉树</p></blockquote><pre><code>        8       /  \      6   10     / \  / \    5  7 9 11    镜像二叉树        8       /  \      10   6     / \  / \    11 9 7  5</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>栈的压入、弹出序列</p><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p></blockquote><p>借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p><p>举例：</p><p>入栈1,2,3,4,5</p><p>出栈4,5,3,2,1</p><p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p><p>此时栈顶2≠4，继续入栈3</p><p>此时栈顶3≠4，继续入栈4</p><p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p><p>此时栈顶3≠5，继续入栈5</p><p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p><p>….</p><p>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        n = len(pushV)</span><br><span class="line">        s = []</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> pushV:</span><br><span class="line">            s.append(v)</span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> s[<span class="number">-1</span>] == popV[j]:</span><br><span class="line">                s.pop()</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>从上往下打印二叉树</p><blockquote><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p></blockquote><p>树的层次遍历，队列实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue, res = [root], []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                res.append(p.val)</span><br><span class="line">                <span class="keyword">if</span> p.left: tmp.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right: tmp.append(p.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>二叉搜索树的后序遍历序列</p><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p>分治拉， 后序遍历是这样的（小于根节点，大于根节点， 根节点），找到小于和大于的分界线，从右向左查找，然后递归判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.verfify(sequence, <span class="number">0</span>, len(sequence) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verfify</span><span class="params">(self, sequence, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        i = end - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= start <span class="keyword">and</span> sequence[i] &gt; sequence[end]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; start: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(start, i + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> sequence[j] &gt; sequence[end]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.verfify(sequence, start, i) <span class="keyword">and</span> self.verfify(sequence, i + <span class="number">1</span>, end - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>二叉树中和为某一值的路径</p><blockquote><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p></blockquote><p>dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, expectNumber, path)</span>:</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == expectNumber: res.append(path[:])</span><br><span class="line">            <span class="keyword">if</span> root.left: dfs(root.left, expectNumber - root.val, path)</span><br><span class="line">            <span class="keyword">if</span> root.right: dfs(root.right, expectNumber - root.val, path)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        dfs(root, expectNumber, path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>复杂链表的复制</p><blockquote><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p></blockquote><p>最简单的方法，先复制一遍不带random的链表，并用字典记录random的指向，第二遍遍历修复random项。复杂度是O(2n)，空间复杂度O(n)。</p><p>O(1)空间的解法如下：</p><ol type="1"><li>在原链表的每个节点后面拷贝出一个新的节点</li><li>依次给新的节点的随机指针赋值，而且这个赋值非常容易 cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</li><li>断开链表可得到深度拷贝后的新链表</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.random = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        dic = dict()</span><br><span class="line">        L = RandomListNode(<span class="number">0</span>)</span><br><span class="line">        p, cur = L, pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = RandomListNode(cur.label)</span><br><span class="line">            dic[cur] = tmp</span><br><span class="line">            p.next = tmp</span><br><span class="line">            p, cur = p.next, cur.next</span><br><span class="line"></span><br><span class="line">        p, cur = L.next, pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            p.random = dic.get(cur.random, <span class="keyword">None</span>)</span><br><span class="line">            p, cur = p.next, cur.next</span><br><span class="line">        <span class="keyword">return</span> L.next</span><br></pre></td></tr></table></figure></li><li><p>二叉搜索树与双向链表</p><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p></blockquote><p>left指向前一个节点，right指向后一个节点，中序遍历。维护一个left最右的指针，然后修正leftmost, root, right之间的关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    leftlast = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, root)</span>:</span> <span class="comment"># 返回最小的那个节点。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            self.leftlast = root</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.Convert(root.left)</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            self.leftlast.right = root</span><br><span class="line">            root.left = self.leftlast</span><br><span class="line">        self.leftlast = root</span><br><span class="line">        right = self.Convert(root.right)</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            right.left = root</span><br><span class="line">            root.right = right</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> root</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>数组中出现次数超过一半的数字</p><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p></blockquote><p>最简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        c = Counter(numbers).most_common(<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> c[<span class="number">0</span>] <span class="keyword">if</span> c[<span class="number">1</span>] &gt; len(numbers)/<span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>复杂点， 借用众数得思想，一次在数组中删除两个不同得数，直到剩下一个数，如果这个数出现得次数大于一半，这个数最后一定会剩下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        cand, times = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> times == <span class="number">0</span>:</span><br><span class="line">                cand, times = number, <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cand == number:</span><br><span class="line">                times += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                times -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> number == cand:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cand <span class="keyword">if</span> c &gt; len(numbers) / <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>最小的K个数</p><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p></blockquote><p>可以用快排，可以用最小堆，还有牛逼得BFPRT算法。</p><p>只能说牛客网比较奇葩，返回结果还需要排序，我去，下列代码会超时，so不如用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">class Solution:</span><br><span class="line">    def GetLeastNumbers_Solution(self, a, k):</span><br><span class="line">        if k &gt; len(a): return []</span><br><span class="line">        l, h = 0, len(a) - 1</span><br><span class="line">        i = self.partition(a, l, h)</span><br><span class="line">        while i != k - 1:</span><br><span class="line">            if i &gt; k - 1:</span><br><span class="line">                i = self.partition(a, l, i - 1)</span><br><span class="line">            else:</span><br><span class="line">                i = self.partition(a, i + 1, h)</span><br><span class="line">        return [a[i] for i in range(k)]</span><br><span class="line"></span><br><span class="line">    def partition(self, a, l, h):</span><br><span class="line">        tmp = a[l]</span><br><span class="line">        while l &lt; h:</span><br><span class="line">            while l &lt; h and a[h] &gt;= tmp: h -= 1</span><br><span class="line">            a[l] = a[h]</span><br><span class="line">            while l &lt; h and a[l] &lt;= tmp: l += 1</span><br><span class="line">            a[h] = a[l]</span><br><span class="line">        a[l] = tmp</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure></p><p>​</p></li><li><p>连续子数组的最大和</p><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><p>_sum局部累加和，_max全部最大和。注意里面_max得初始值，和求max得顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        _max, _sum = <span class="number">-0x80000000</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            _sum += i</span><br><span class="line">            _max = max(_sum, _max) <span class="comment">#写在下一句之前，保证_max可以为负数</span></span><br><span class="line">            <span class="keyword">if</span> _sum &lt; <span class="number">0</span>: _sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> _max</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>整数中1出现的次数（从1到n整数中1出现的次数）</p><blockquote><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p></blockquote><p>详解：https://leetcode.com/problems/number-of-digit-one/discuss/64381</p><p>把数字划分为两部分，如n=3141592, 考虑百分位，m=100, 则a=31415, b = 92 ，然后我们知道n的百分位为1的前缀是从‘’“到3141，共3142次，后缀都是100次，也就是<span class="math display">\[(a/10 + 1) * 100\]</span>。</p><p>再考虑千分位，m=1000, a=3141, b = 592, 千分位为1的前缀是‘’”到314，共315次，但是千位数是1，后缀并不都是1000次，只有593次，另外一种情况是后缀是“000”到“592”。所以 <span class="math display">\[(a/10 * 1000)+(b+1)\]</span>。</p><p>当前位置是0还是1或者&gt;=2可以用一个公式表达，也就是<span class="math display">\[(a+8)/10\]</span>，最后的部分尾巴用a%10==1判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ones, m = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> m &lt;= n:</span><br><span class="line">            a, b = n // m, n % m</span><br><span class="line">            ones += (a + <span class="number">8</span>) // <span class="number">10</span> * m + (a % <span class="number">10</span> == <span class="number">1</span>) * (b + <span class="number">1</span>)</span><br><span class="line">            m *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>把数组排成最小的数</p><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></blockquote><p>排序，怎么排序呢？</p><p>如果我们有s1=9, s2=31,排列有s1+s2, s2+s1，本地求最小，当然选拼接起来小的那一种。python3取消了sort的cmp方法,但保留在functools中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums</span></span><br><span class="line">    <span class="comment"># @return &#123;string&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> nums]</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line">        nums.sort(key=cmp_to_key(<span class="keyword">lambda</span> x, y: int(x+y)-int(y+x)))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(nums) <span class="keyword">or</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>第一个只出现一次的字符</p><blockquote><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p></blockquote><p>判断当前位置得字符s[i]是否在s[:i]+s[i+1:]中。普通做法，256长的数组记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> s[:i]+s[i+<span class="number">1</span>:]: <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>数组中的逆序对</p><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><p>题目保证输入的数组中没有的相同的数字数据范围：对于%50的数据,size&lt;=10<sup>4</sup> 对于%75的数据,size&lt;=10<sup>5</sup> 对于%100的数据,size&lt;=2*10<sup>5</sup></p><p>示例</p><p>输入 : 1,2,3,4,5,6,7,0</p><p>输出 : 7</p></blockquote><p>归并排序。如果是求重要逆序数，记得先不进行归并，先求count，然后再做一遍归并（leetcode 193）。很遗憾，牛客网超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        C = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> j &lt; len(B):</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt;= B[j]:</span><br><span class="line">                C.append(A[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += len(A) - i</span><br><span class="line">                C.append(B[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            C.extend(A[i:])</span><br><span class="line">            C.extend(B[j:])</span><br><span class="line">            <span class="keyword">return</span> count, C</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, nums</span><br><span class="line">        m = len(nums) // <span class="number">2</span></span><br><span class="line">        a, left = self.mergesort(nums[:m])</span><br><span class="line">        b, right = self.mergesort(nums[m:])</span><br><span class="line">        c, res = self.merge(left, right)</span><br><span class="line">        <span class="keyword">return</span> a + b + c, res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        c, _ = self.mergesort(data)</span><br><span class="line">        <span class="keyword">return</span> c % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>两个链表的第一个公共结点</p><blockquote><p>输入两个链表，找出它们的第一个公共结点。</p></blockquote><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure><p>笨一点得方法是先求出A, B 连链表得长度（假设A比较长)， 那么A从len(A) - len(B)处开始和B比较，这样两者判断得长度一样。</p><p>当然，还有比较巧妙地写法。</p><p>p1, p2指针分别指向A, B得head，任一指针到达链表尾，则指向另一链表得头，继续第二轮比较。在第二轮中，他们要么相遇， 要么没有。如果相遇，该点即为所求，如果没有相遇，他们会在同一轮到达链表尾，也就是 p1=p2=None，返回None。（详情见https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49798）</p><p>解释：两个指针走的总路程相同，如果有交点，短的指针先走完，然后换到长链表那补全他楼下的路程。如果没有交点，最终都会走向链表尾部。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1, p2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">is</span> <span class="keyword">not</span> p2:</span><br><span class="line">            p1 = p1.next <span class="keyword">if</span> p1 <span class="keyword">else</span> headB</span><br><span class="line">            p2 = p2.next <span class="keyword">if</span> p2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>数字在排序数组中出现的次数</p><blockquote><p>统计一个数字在排序数组中出现的次数。</p></blockquote><p>遍历</p><p>二分查找left和right</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        left = bisect.bisect_left(data, k)</span><br><span class="line">        right = bisect.bisect_right(data, k)</span><br><span class="line">        <span class="keyword">return</span> right - left</span><br></pre></td></tr></table></figure><p>复习下这两种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></li><li><p>二叉树的深度</p><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> max(self.TreeDepth(pRoot.left), self.TreeDepth(pRoot.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>平衡二叉树</p><blockquote><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p></blockquote><p>借用上题得求深度函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left), self.depth(root.right)) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.depth(root.left) - self.depth(root.right)) &lt; <span class="number">2</span> <span class="keyword">and</span> self.IsBalanced_Solution(root.left) <span class="keyword">and</span> self.IsBalanced_Solution(root.right)</span><br></pre></td></tr></table></figure><p>当前，上述解法存在重复计算。我们可以采用后序遍历的方法，判断时就可以知道两边节点的深度。</p><p>​</p></li><li><p>数组中只出现一次的数字</p><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p></blockquote><p>基础版本：一个整型数组里除了一个数字之外，其它的数字都出现了两次。请写程序找出这个只出现一次的数字。</p><p>这个比较好做，直接采用异或操作，剩下得就是只出现一次得。</p><p>本题是上述得扩展，把数组划分成两部分，每一部分包含一个只出现一次的数字，之后就是异或拉。怎么拆分呢？对所有数组异或，结果肯定不为0，因为有两个只出现一次得数字。在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N位都为1，而第二个子数组的每个数字的第N位都为0。</p><p>详情见（http://blog.csdn.net/u011826264/article/details/39269101）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array: n ^= i</span><br><span class="line">        n = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">        j = n.find(<span class="string">'1'</span>)</span><br><span class="line">        a1 = filter(<span class="keyword">lambda</span> x: bin(x)[<span class="number">2</span>:].zfill(len(n))[::<span class="number">-1</span>][j] == <span class="string">'1'</span>, array)</span><br><span class="line">        a2 = filter(<span class="keyword">lambda</span> x: bin(x)[<span class="number">2</span>:].zfill(len(n))[::<span class="number">-1</span>][j] == <span class="string">'0'</span>, array)</span><br><span class="line">        num1, num2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a1: num1 ^= i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a2: num2 ^= i</span><br><span class="line">        <span class="keyword">return</span> [num1, num2]</span><br></pre></td></tr></table></figure><p>写完得感受是，python大法好。</p><p>​</p></li><li><p>和为S的连续正数序列</p><blockquote><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p>输出描述:</p><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p></blockquote><p>双指针，大了就h–,小了就l++。l到h得和就用<span class="math display">\[(h+l)*(h-l+1)/2\]</span>表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        l, h = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            cur = (h + l) * ( h - l + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> cur &lt; tsum: h += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur == tsum:</span><br><span class="line">                res.append(list(range(l, h+<span class="number">1</span>)))</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; tsum:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>和为S的两个数字</p><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>输出描述:</p><p>对应每个测试案例，输出两个数，小的先输出。</p></blockquote><p>双指针遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, target)</span>:</span></span><br><span class="line">        n = len(array)</span><br><span class="line">        l, h = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            t = array[l] + array[h]</span><br><span class="line">            <span class="keyword">if</span> t &gt; target:</span><br><span class="line">                h -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> t &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [array[l], array[h]]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>左旋转字符串</p><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p></blockquote><p>字符串截取，用py很好实现，注意取模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">return</span> s[k%n:]+s[:k%n]</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>翻转单词顺序列</p><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p></blockquote><p>python2 和 python3 有些不一样，牛客网是python2，split函数有些小区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(s.split(<span class="string">' '</span>)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>扑克牌顺子</p><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p></blockquote><p>必须满足两个条件: 1. 除0外没有重复的数; 2. max - min &lt; 5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length != <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> number = numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(number &lt; <span class="number">0</span> || number &gt; <span class="number">13</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(number == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(((flag &gt;&gt; number) &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            flag |= (<span class="number">1</span> &lt;&lt; number);</span><br><span class="line">            <span class="keyword">if</span>(number &gt; max) max = number;</span><br><span class="line">            <span class="keyword">if</span>(number &lt; min) min = number;</span><br><span class="line">            <span class="keyword">if</span>(max - min &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>孩子们的游戏(圆圈中最后剩下的数)</p><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p></blockquote><p>用数组模拟，但是超时了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> m &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        kids = [<span class="number">1</span>] * n</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> c &lt; m - <span class="number">1</span>:</span><br><span class="line">                j = (j + <span class="number">1</span>) % n</span><br><span class="line">                <span class="keyword">if</span> kids[j]: c += <span class="number">1</span></span><br><span class="line">            kids[j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><p>数学的归纳法：</p><p>令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]。</p><p>递推公式</p><p>f[1]=0;</p><p>f[i]=(f[i-1]+m)%i; (i&gt;1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> m &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            s = (s + m) % i</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>求1+2+3+…+n</p><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote><p><span class="math display">\[\frac{n^2+n}{2}\]</span> , 用乘方、加、右移实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (n ** <span class="number">2</span> + n) &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>把字符串转换成整数</p><blockquote><p>题目描述</p><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><p>输入描述:</p><p>输入一个字符串,包括数字字母符号,可以为空</p><p>输出描述:</p><p>如果是合法的数值表达则返回该数字，否则返回0</p><p>示例1</p><p>输入 +2147483647 1a33</p><p>输出 2147483647 0</p></blockquote><p>遍历，遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        res, base, i = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        flag = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">'+-'</span>: i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>: flag = <span class="keyword">False</span></span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= i:</span><br><span class="line">            <span class="keyword">if</span> s[j].isdigit():</span><br><span class="line">                res += (ord(s[j]) - ord(<span class="string">'0'</span>)) * base</span><br><span class="line">                base *= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> flag <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>数组中重复的数字</p><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></blockquote><p>判断i是否在n[:i]之中就行，但是python怎么也过不了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] <span class="keyword">in</span> numbers[:i]:</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>java可以过的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] k = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k[numbers[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k[numbers[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​空间复杂度为O(1)的解法是，交换，如果当前位置的数和序号相等，则继续，若不等，比较当前数和他该待着的位置的数比较，如果相等，那么我们找到一个重复的，不等则swap，继续比较。</p></li><li><p>构建乘积数组</p><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p></blockquote><p>left保持左侧连乘，right保存右侧起的连乘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        left, right = [<span class="number">1</span>], [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            left.append(left[<span class="number">-1</span>] * i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A[::<span class="number">-1</span>]:</span><br><span class="line">            right.append(right[<span class="number">-1</span>] * i)</span><br><span class="line">        B = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            B.append(left[i] * right[<span class="number">-2</span>-i])</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>正则表达式匹配</p><blockquote><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>’表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串“aaa”与模式“a.a”和“ab<em>ac</em>a”匹配，但是与“aa.a”和“ab*a“均不匹配</p></blockquote><p>动态规划拉。</p><p>This problem has a typical solution using Dynamic Programming. We define the state <code>P[i][j]</code> to be <code>true</code> if <code>s[0..i)</code> matches <code>p[0..j)</code> and <code>false</code> otherwise. Then the state equations are:</p><ol type="1"><li><code>P[i][j] = P[i - 1][j - 1]</code>, if <code>p[j - 1] != '*' &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')</code>;</li><li><code>P[i][j] = P[i][j - 2]</code>, if <code>p[j - 1] == '*'</code> and the pattern repeats for <code>0</code> times;</li><li><code>P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.')</code>, if <code>p[j - 1] == '*'</code> and the pattern repeats for at least <code>1</code> times.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] <span class="keyword">or</span> (</span><br><span class="line">                            i &gt; <span class="number">0</span> <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">'.'</span>) <span class="keyword">and</span> dp[i - <span class="number">1</span>][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> <span class="keyword">and</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>表示数值的字符串</p><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”,“5e2”,“-123”,“3.1416”和“-1E-16”都表示数值。 但是“12e”,“1a3.14”,“1.2.3”,“+-5”和“12e+4.3”都不是。</p></blockquote><p>正则表达式比较简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> re.match(<span class="string">r"^[+-]?[0-9]*(\.[0-9]*)?([eE][+-]?[0-9]+)?$"</span>, s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>字符流中第一个不重复的字符</p><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符“go”时，第一个只出现一次的字符是“g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是“l”。</p><p>输出描述:</p><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p></blockquote><p>用一个队列（保证输出第一个出现一次的字符）和数组（anscii码256）实现，每次insert时候判断当前字符的次数，如果只出现一次，插入到队列中，输出时要再判断一下该字符是否只出现一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">        self.q = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.q <span class="keyword">and</span> self.s[ord(self.q[<span class="number">0</span>])] &gt; <span class="number">1</span>: self.q.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.q: <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        self.s[ord(c)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.s[ord(c)] == <span class="number">1</span>:</span><br><span class="line">            self.q.append(c)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>链表中环的入口结点</p><blockquote><p>一个链表中包含环，请找出该链表的环的入口结点。</p></blockquote><p>快慢指针发现是否有环（leetcode 141）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        p1, p2 = head, head</span><br><span class="line">        <span class="keyword">while</span> p1.next <span class="keyword">and</span> p2.next <span class="keyword">and</span> p2.next.next:</span><br><span class="line">            p1, p2 = p1.next, p2.next.next</span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><img src="http://images.cnitblog.com/blog/528669/201407/230518072134822.png"></p><p>从链表起始处到环入口长度为：a，从环入口到Faster和Slower相遇点长度为：x，整个环长为：c。</p><p>假设从开始到相遇，Slower走过的路程长为s，由于Faster的步速是Slower的2倍，那么Faster在这段时间走的路程长为2s。</p><p>而对于Faster来说，他走的路程还等于之前绕整个环跑的n圈的路程nc，加上最后这一次遇见Slower的路程s。</p><p>所以我们有：</p><p>​ 2s = nc + s</p><p>对于Slower来说，他走的路程长度s还等于他从链表起始处到相遇点的距离，所以有：</p><p>​ s = a + x</p><p>通过以上两个式子代入化简有：</p><p>​ a + x = nc</p><p>​ a = nc - x</p><p>​ a = (n-1)c + c-x</p><p>​ a = kc + (c-x)</p><p>那么可以看出，c-x，就是从相遇点继续走回到环入口的距离。上面整个式子可以看出，如果此时有个pointer1从起始点出发并且同时还有个pointer2从相遇点出发继续往前走（都只迈一步），那么绕过k圈以后， pointer2会和pointer1在环入口相遇。这样，换入口就找到了。(摘自https://www.cnblogs.com/springfor/p/3862125.html)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1, p2 = head, head</span><br><span class="line">        hasCycle = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> p1.next <span class="keyword">and</span> p2.next <span class="keyword">and</span> p2.next.next:</span><br><span class="line">            p1, p2 = p1.next, p2.next.next</span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                hasCycle = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasCycle: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p2 = head</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1, p2 = p1.next, p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>删除链表中重复的结点</p><blockquote><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p></blockquote><p>重复的保留一个(leetcode 83)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            pos = cur.next</span><br><span class="line">            <span class="keyword">if</span> pos.val == cur.val:</span><br><span class="line">                cur.next = pos.next</span><br><span class="line">                <span class="keyword">del</span> pos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = pos</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>一个不留的(leetcode 82)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        dump = ListNode(<span class="number">0</span>)</span><br><span class="line">        pre, dump.next, cur = dump, head, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.next.val == cur.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> pre.next == cur:  <span class="comment"># 说明不重复，没有删除元素</span></span><br><span class="line">                pre = pre.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dump.next</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>二叉树的下一个结点</p><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><p>分析二叉树的下一个节点，一共有以下情况：</p><p>1.二叉树为空，则返回空；</p><p>2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；</p><p>3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p><figure><img src="/images/剑指offer_55.png" alt="55"><figcaption>55</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            root = root.right</span><br><span class="line">            <span class="keyword">while</span> root.left:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">while</span> root.next:</span><br><span class="line">            p = root.next</span><br><span class="line">            <span class="keyword">if</span> p.left == root: <span class="keyword">return</span> p</span><br><span class="line">            root = root.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>对称的二叉树</p><blockquote><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p></blockquote><p>一开始想得是层次遍历，然后判断每层是否对称，后来发现不对，因为，如如果某一层是 4 # 2 4，满足要求但不是对称得。</p><p>其实就是dfs啊。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left == right</span><br><span class="line">            <span class="keyword">return</span> left.val == right.val <span class="keyword">and</span> check(left.left, right.right) <span class="keyword">and</span> check(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> root <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> check(root.left, root.right)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>按之字形顺序打印二叉树</p><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p></blockquote><p>层次遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        flag = <span class="keyword">True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp, tmpval = [], []</span><br><span class="line">            i = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i: tmpval.append(p.val)</span><br><span class="line">                <span class="keyword">else</span>: tmpval.insert(<span class="number">0</span>, p.val)</span><br><span class="line">                <span class="keyword">if</span> p.left: tmp.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right: tmp.append(p.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">            res.append(tmpval)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>我以前leetcode上的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        queue, res = collections.deque([(root, <span class="number">0</span>)]), []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, level = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> len(res) &lt; level + <span class="number">1</span>:</span><br><span class="line">                    res.insert(level, [])</span><br><span class="line">                <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    res[level].append(node.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[level].insert(<span class="number">0</span>, node.val)</span><br><span class="line">                queue.append((node.left, level + <span class="number">1</span>))</span><br><span class="line">                queue.append((node.right, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>把二叉树打印成多行</p><blockquote><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p></blockquote><p>层次遍历。我的习惯性做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp, tmpval = [], []</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                tmpval.append(p.val)</span><br><span class="line">                <span class="keyword">if</span> p.left: tmp.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right: tmp.append(p.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">            res.append(tmpval)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>当然，可以改进下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            n = len(queue)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> queue:</span><br><span class="line">                tmp.append(p.val)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> p.left: queue.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right: queue.append(p.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>序列化二叉树</p><blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树</p></blockquote><p>先序遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">doit</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                vals.append(str(node.val))</span><br><span class="line">                doit(node.left)</span><br><span class="line">                doit(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vals.append(<span class="string">'#'</span>)</span><br><span class="line">        vals = []</span><br><span class="line">        doit(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(vals)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">doit</span><span class="params">()</span>:</span></span><br><span class="line">            val = next(vals)</span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">'#'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            node = TreeNode(int(val))</span><br><span class="line">            node.left = doit()</span><br><span class="line">            node.right = doit()</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        vals = iter(data.split())</span><br><span class="line">        <span class="keyword">return</span> doit()</span><br></pre></td></tr></table></figure></li><li><p>二叉搜索树的第k个结点</p><blockquote><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 /  3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p></blockquote><p>中序遍历吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            dfs(root.left, res)</span><br><span class="line">            res.append(root)</span><br><span class="line">            dfs(root.right, res)</span><br><span class="line"></span><br><span class="line">        dfs(root, res)</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>] <span class="keyword">if</span> k &lt;= len(res) <span class="keyword">else</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>改进下，这个递归有点难懂，在到达k个节点之前是不会返回的，到达k时返回return root, 上层的就继续返回return left or return right：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            left = self.KthNode(root.left, k)</span><br><span class="line">            <span class="keyword">if</span> left: <span class="keyword">return</span> left</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.count == k: <span class="keyword">return</span> root</span><br><span class="line">            right = self.KthNode(root.right, k)</span><br><span class="line">            <span class="keyword">if</span> right: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>数据流中的中位数</p><blockquote><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p></blockquote><p>解题思路就是用两个堆，一个大顶堆，一个小顶堆来过滤数据。大顶堆代表排序后得左边数据，小顶堆代表右半边数据。维持这一特性即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.maxheap = []</span><br><span class="line">        self.minheap = []</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            heapq.heappush(self.maxheap, -num)</span><br><span class="line">            tmp = -heapq.heappop(self.maxheap)</span><br><span class="line">            heapq.heappush(self.minheap, tmp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.minheap, num)</span><br><span class="line">            tmp = -heapq.heappop(self.minheap)</span><br><span class="line">            heapq.heappush(self.maxheap, tmp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (-self.maxheap[<span class="number">0</span>] + self.minheap[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -self.maxheap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>还是牛客网过不了，奇怪得报错。</p><p>牛客网的一个写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">  <span class="function">pulic <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(p.empty() || num &lt;= p.top()) p.push(num);</span><br><span class="line">      <span class="keyword">else</span> q.push(num);</span><br><span class="line">      <span class="keyword">if</span>(p.size() == q.size() + <span class="number">2</span>) q.push(p.top()), p.pop();</span><br><span class="line">      <span class="keyword">if</span>(p.size() + <span class="number">1</span> == q.size()) p.push(q.top()), q.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p.size() == q.size() ? (p.top() + q.top()) / <span class="number">2.0</span> : p.top();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            v.push_back(num);</span><br><span class="line">            n = v.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; v[i] &lt; v[i - <span class="number">1</span>]; --i) swap(v[i], v[i - <span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span>&#123; </span><br><span class="line">          <span class="keyword">return</span> (v[(n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>] + v[n &gt;&gt; <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>滑动窗口的最大值</p><blockquote><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p></blockquote><p>我的想法简单，维持滑动窗口得最大值，就三种情况，最大值在当前位置，在上一窗口和当前窗口重叠得部分，上一轮最大值被抛弃。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">1</span> <span class="keyword">or</span> size &gt; len(num): <span class="keyword">return</span> []</span><br><span class="line">        _max = max(num[:size])</span><br><span class="line">        res = [_max]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size, len(num)):</span><br><span class="line">            <span class="keyword">if</span> num[i] &gt; num[i - size]:</span><br><span class="line">                _max = max(_max, num[i])</span><br><span class="line">            <span class="keyword">elif</span> _max == num[i - size]:</span><br><span class="line">                _max = max(num[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">            res.append(_max)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>感觉牛客网上推荐得答案也不是太好，话不如直接max函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">用一个双端队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次</span></span><br><span class="line"><span class="comment">1.判断当前最大值是否过期</span></span><br><span class="line"><span class="comment">2.新增加的值从队尾开始比较，把所有比他小的值丢掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> begin; </span><br><span class="line">        ArrayDeque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)&#123;</span><br><span class="line">            begin = i - size + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q.isEmpty())</span><br><span class="line">                q.add(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(begin &gt; q.peekFirst())</span><br><span class="line">                q.pollFirst();</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">while</span>((!q.isEmpty()) &amp;&amp; num[q.peekLast()] &lt;= num[i])</span><br><span class="line">                q.pollLast();</span><br><span class="line">            q.add(i);  </span><br><span class="line">            <span class="keyword">if</span>(begin &gt;= <span class="number">0</span>)</span><br><span class="line">                res.add(num[q.peekFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>矩阵中的路径</p><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串“bcced”的路径，但是矩阵中不包含“abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p></blockquote><p>dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        visit = [<span class="keyword">False</span>] * (cols *rows)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(matrix, rows, cols, path, visit, i, j, k)</span>:</span></span><br><span class="line">            index = i * cols + j</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= rows <span class="keyword">or</span> j &gt;= cols <span class="keyword">or</span> visit[index] <span class="keyword">or</span> matrix[index] != path[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> k == len(path) - <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            visit[index] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> dfs(matrix, rows, cols, path, visit, i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    dfs(matrix, rows, cols, path, visit, i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    dfs(matrix, rows, cols, path, visit, i, j - <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    dfs(matrix, rows, cols, path, visit, i, j + <span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            visit[index] = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> dfs(matrix, rows, cols, path, visit, i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>机器人的运动范围</p><blockquote><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p></blockquote><p>dfs拉，改改上一题得就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        visit = [[<span class="keyword">False</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> range(rows)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(rows, cols, visit, i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= rows <span class="keyword">or</span> j &gt;= cols <span class="keyword">or</span> visit[i][j] <span class="keyword">or</span> \</span><br><span class="line">                    sum(map(int, [i <span class="keyword">for</span> i <span class="keyword">in</span> str(i) + str(j)])) &gt; k:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visit[i][j] = <span class="keyword">True</span></span><br><span class="line">            dfs(rows, cols, visit, i - <span class="number">1</span>, j, k)</span><br><span class="line">            dfs(rows, cols, visit, i + <span class="number">1</span>, j, k)</span><br><span class="line">            dfs(rows, cols, visit, i, j - <span class="number">1</span>, k)</span><br><span class="line">            dfs(rows, cols, visit, i, j + <span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                dfs(rows, cols, visit, i, j, threshold)</span><br><span class="line">        <span class="keyword">return</span> sum([sum(i) <span class="keyword">for</span> i <span class="keyword">in</span> visit])</span><br></pre></td></tr></table></figure></li></ol><p>结论：</p><p>​ 刷到最后20道左右时，就有些浮躁，想不出题解就直接看我leetcode上的solution了，尴尬，刷题还是不能浮躁，得沉住气。</p><p>​ 并且，刷完发现少了2道题，这，懒得找了，哈哈。</p><p>​ 当然，我的所有代码都是python3写的，有的在牛客网网通过不了，因为牛客网只支持python2。by，全文中得其他语言所写代码几乎是网上借鉴得写法。</p><p>​ 2018.1.5 中科院软件所</p>]]></content>
    
    <summary type="html">
    
      &lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;字符串的排列&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;
&lt;p&gt;输入描述:&lt;/p&gt;
&lt;p&gt;输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;dfs， 但是牛客网有些尴尬，list的顺序还得保障，所以结果得sort一下。为了防止重复，用了set。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Permutation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ss)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; ss: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res = set()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(res, ss, s)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; ss: res.add(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(ss)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                s = s + ss[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dfs(res, ss[:i] + ss[i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:], s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                s = s[:&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dfs(res, ss, &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sorted(list(res))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，这只是简单得写法。高级得用swap实现，详情见STL中得permutation经典算法。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="http://wuqiansheng.xyz/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="Python" scheme="http://wuqiansheng.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow Solve Mnist 2</title>
    <link href="http://wuqiansheng.xyz/2017/04/03/Tensorflow-Solve-Mnist-2/"/>
    <id>http://wuqiansheng.xyz/2017/04/03/Tensorflow-Solve-Mnist-2/</id>
    <published>2017-04-03T07:29:26.000Z</published>
    <updated>2017-04-03T07:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="卷积神经网络解决mnist识别">卷积神经网络解决MNIST识别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2017/4/3 11:40</span></span><br><span class="line"><span class="comment"># @Author  : wqs</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"MNIST_data/"</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">x = tf.placeholder(<span class="string">"float"</span>, [<span class="keyword">None</span>, <span class="number">784</span>])</span><br><span class="line">y_ = tf.placeholder(<span class="string">"float"</span>, [<span class="keyword">None</span>,<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.truncated_normal(shape, stddev=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.constant(<span class="number">0.1</span>, shape=shape)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x, W)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.conv2d(x, W, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool_2x2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(x, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                          strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br><span class="line"></span><br><span class="line">W_conv1 = weight_variable([<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">32</span>]) <span class="comment"># patch:5X5, 通道深度为1, 通道输出数目为30</span></span><br><span class="line">b_conv1 = bias_variable([<span class="number">32</span>])</span><br><span class="line"></span><br><span class="line">x_image = tf.reshape(x, [<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</span><br><span class="line">h_pool1 = max_pool_2x2(h_conv1)</span><br><span class="line"></span><br><span class="line">W_conv2 = weight_variable([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>])</span><br><span class="line">b_conv2 = bias_variable([<span class="number">64</span>])</span><br><span class="line"></span><br><span class="line">h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</span><br><span class="line">h_pool2 = max_pool_2x2(h_conv2)</span><br><span class="line"></span><br><span class="line">W_fc1 = weight_variable([<span class="number">7</span> * <span class="number">7</span> * <span class="number">64</span>, <span class="number">1024</span>])</span><br><span class="line">b_fc1 = bias_variable([<span class="number">1024</span>])</span><br><span class="line"></span><br><span class="line">h_pool2_flat = tf.reshape(h_pool2, [<span class="number">-1</span>, <span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>])</span><br><span class="line">h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</span><br><span class="line"></span><br><span class="line">keep_prob = tf.placeholder(<span class="string">"float"</span>)</span><br><span class="line">h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</span><br><span class="line"></span><br><span class="line">W_fc2 = weight_variable([<span class="number">1024</span>, <span class="number">10</span>])</span><br><span class="line">b_fc2 = bias_variable([<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">cross_entropy = tf.reduce_mean(</span><br><span class="line">    tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y_conv))</span><br><span class="line">train_step = tf.train.AdamOptimizer(<span class="number">1e-4</span>).minimize(cross_entropy)</span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y_conv,<span class="number">1</span>), tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2000</span>):</span><br><span class="line">  batch = mnist.train.next_batch(<span class="number">50</span>)</span><br><span class="line">  <span class="keyword">if</span> i%<span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">    train_accuracy = accuracy.eval(session=sess, feed_dict=&#123;</span><br><span class="line">        x:batch[<span class="number">0</span>], y_: batch[<span class="number">1</span>], keep_prob: <span class="number">1.0</span>&#125;)</span><br><span class="line">    print(<span class="string">"step %d, training accuracy %g"</span>%(i, train_accuracy))</span><br><span class="line">  train_step.run(session=sess, feed_dict=&#123;x: batch[<span class="number">0</span>], y_: batch[<span class="number">1</span>], keep_prob: <span class="number">0.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"test accuracy %g"</span>%accuracy.eval(session=sess, feed_dict=&#123;</span><br><span class="line">    x: mnist.test.images, y_: mnist.test.labels, keep_prob: <span class="number">1.0</span>&#125;))</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;卷积神经网络解决mnist识别&quot;&gt;卷积神经网络解决MNIST识别&lt;/h4&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="tensorflow" scheme="http://wuqiansheng.xyz/tags/tensorflow/"/>
    
      <category term="python" scheme="http://wuqiansheng.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow Solve Mnist 1</title>
    <link href="http://wuqiansheng.xyz/2017/04/03/Tensorflow-Solve-Mnist-1/"/>
    <id>http://wuqiansheng.xyz/2017/04/03/Tensorflow-Solve-Mnist-1/</id>
    <published>2017-04-03T07:27:44.000Z</published>
    <updated>2017-04-03T07:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单层神经网络解决mnist识别">单层神经网络解决MNIST识别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"MNIST_data/"</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = tf.placeholder(<span class="string">"float"</span>, [<span class="keyword">None</span>, <span class="number">784</span>])</span><br><span class="line">W = tf.Variable(tf.zeros([<span class="number">784</span>,<span class="number">10</span>]))</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">10</span>]))</span><br><span class="line">y = tf.nn.softmax(tf.matmul(x,W) + b)</span><br><span class="line"></span><br><span class="line">y_ = tf.placeholder(<span class="string">"float"</span>, [<span class="keyword">None</span>,<span class="number">10</span>])</span><br><span class="line">cross_entropy = -tf.reduce_sum(y_*tf.log(y))</span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.01</span>).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">  batch_xs, batch_ys = mnist.train.next_batch(<span class="number">100</span>)</span><br><span class="line">  sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)</span><br><span class="line"></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y,<span class="number">1</span>), tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, <span class="string">"float"</span>))</span><br><span class="line">print(sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单层神经网络解决mnist识别&quot;&gt;单层神经网络解决MNIST识别&lt;/h4&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="tensorflow" scheme="http://wuqiansheng.xyz/tags/tensorflow/"/>
    
      <category term="python" scheme="http://wuqiansheng.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode29. Divide Two Integers</title>
    <link href="http://wuqiansheng.xyz/2017/02/22/leetcode29-Divide-Two-Integers/"/>
    <id>http://wuqiansheng.xyz/2017/02/22/leetcode29-Divide-Two-Integers/</id>
    <published>2017-02-22T11:12:11.000Z</published>
    <updated>2017-02-22T11:23:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Divide two integers without using multiplication, division and mod operator.</p><p>If it is overflow, return MAX_INT.</p></blockquote><p>题目链接：https://leetcode.com/problems/divide-two-integers/?tab=Description</p><h4 id="提示">提示</h4><p>不能用乘除和取模，首先想到得减法， 但是减法会超时，我们可以采用指数衰减得减法。 b(1+2<sup>1</sup>+2<sup>2</sup>+…)+c = a</p><a id="more"></a><h4 id="python">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dividend: int</span></span><br><span class="line"><span class="string">        :type divisor: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sign = (dividend &lt; <span class="number">0</span> <span class="keyword">and</span> divisor &gt; <span class="number">0</span>) <span class="keyword">or</span> (dividend &gt; <span class="number">0</span> <span class="keyword">and</span> divisor &lt; <span class="number">0</span>)</span><br><span class="line">        a, b = abs(dividend), abs(divisor)</span><br><span class="line">        ret, c = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> a &gt;= b:</span><br><span class="line">            c = b</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> a &gt;= c:</span><br><span class="line">                a -= c</span><br><span class="line">                ret += (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                c &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sign:</span><br><span class="line">            ret = -ret</span><br><span class="line">        <span class="keyword">return</span> min(max(<span class="number">-2147483648</span>, ret), <span class="number">2147483647</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.divide(<span class="number">5</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Divide two integers without using multiplication, division and mod operator.&lt;/p&gt;
&lt;p&gt;If it is overflow, return MAX_INT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目链接：https://leetcode.com/problems/divide-two-integers/?tab=Description&lt;/p&gt;
&lt;h4 id=&quot;提示&quot;&gt;提示&lt;/h4&gt;
&lt;p&gt;不能用乘除和取模，首先想到得减法， 但是减法会超时，我们可以采用指数衰减得减法。 b(1+2&lt;sup&gt;1&lt;/sup&gt;+2&lt;sup&gt;2&lt;/sup&gt;+…)+c = a&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://wuqiansheng.xyz/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>A Brief Introduction To Recommender System</title>
    <link href="http://wuqiansheng.xyz/2016/12/12/A-Brief-Introduction-To-Recommender-System/"/>
    <id>http://wuqiansheng.xyz/2016/12/12/A-Brief-Introduction-To-Recommender-System/</id>
    <published>2016-12-12T07:18:18.000Z</published>
    <updated>2018-04-06T11:47:04.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐系统简介一">推荐系统简介（一）</h2><h3 id="为什么需要需要系统">为什么需要需要系统</h3><ol type="1"><li>信息复杂，不同的用户偏好；</li><li>提高驻留时间、长尾、转化率和收益。</li></ol><h3 id="历史">历史</h3><ol type="1"><li>信息检索和信息过滤</li><li>手动协同过滤，Tapestry</li><li>自动协同过滤，GroupLens</li></ol><h3 id="分析框架">分析框架</h3><ol type="1"><li>领域：商业</li><li>目的：推荐商品、信息</li><li>推荐内容：情景相关</li><li>谁的建议：专家、普通人</li><li>个性化水平：基于人口统计的，非个性化的，个性化的</li><li>隐私和可靠性：隐私保护和推荐是否被商业利用</li><li>接口：输入（清楚|模糊）和输出接口</li><li>推荐算法：基于内容、知识、协同过滤等。</li></ol><h3 id="构成">构成</h3><ol type="1"><li><p>用户</p></li><li><p>物品</p></li><li><p>评价</p></li><li><p>社区</p><figure><img src="images/A-Brief-Introduction-To-Recommender-System/A-Brief-Introduction-To-Recommender-System/Component_in_RS.png" alt="Component_in_RS"><figcaption>Component_in_RS</figcaption></figure></li></ol><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;推荐系统简介一&quot;&gt;推荐系统简介（一）&lt;/h2&gt;
&lt;h3 id=&quot;为什么需要需要系统&quot;&gt;为什么需要需要系统&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;信息复杂，不同的用户偏好；&lt;/li&gt;
&lt;li&gt;提高驻留时间、长尾、转化率和收益。&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
    
      <category term="推荐系统" scheme="http://wuqiansheng.xyz/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>博客添加打赏功能</title>
    <link href="http://wuqiansheng.xyz/2016/09/23/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://wuqiansheng.xyz/2016/09/23/博客添加打赏功能/</id>
    <published>2016-09-23T09:48:28.000Z</published>
    <updated>2016-09-23T11:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>我使用的主题是yilia，在此以此为例。</p><h4 id="第一步-编写打赏模块">第一步: 编写打赏模块</h4><p>主题文件 layout\_partial 下新建 donate.ejs , 内容如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;! -- 添加捐赠图标 --&gt;</span><br><span class="line">&lt;div class =&quot;post-donate&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;donate_board&quot; class=&quot;donate_bar center&quot;&gt;</span><br><span class="line">        &lt;a id=&quot;btn_donate&quot; class=&quot;btn_donate&quot; href=&quot;javascript:;&quot; title=&quot;打赏&quot;&gt;&lt;/a&gt;</span><br><span class="line">        &lt;span class=&quot;donate_txt&quot;&gt;</span><br><span class="line">           &amp;uarr;&lt;br&gt;</span><br><span class="line">   &lt;%=theme.donate_message%&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">      &lt;/div&gt;  </span><br><span class="line">&lt;div id=&quot;donate_guide&quot; class=&quot;donate_bar center hidden&quot; &gt;</span><br><span class="line">&lt;!-- 支付宝打赏图案 --&gt;</span><br><span class="line">&lt;img src=&quot;支付宝支付图片链接&quot; alt=&quot;支付宝打赏&quot;&gt; </span><br><span class="line">&lt;!-- 微信打赏图案 --&gt;</span><br><span class="line">&lt;img src=&quot;微信支付图片链接&quot; alt=&quot;微信打赏&quot;&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">document.getElementById(&apos;btn_donate&apos;).onclick = function()&#123;</span><br><span class="line">$(&apos;#donate_board&apos;).addClass(&apos;hidden&apos;);</span><br><span class="line">$(&apos;#donate_guide&apos;).removeClass(&apos;hidden&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;! -- 添加捐赠图标 --&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="第二步-设置大赏模块的样式">第二步 : 设置大赏模块的样式</h4><p>source\css\_partial 下新建 donate.styl 输入如下内容 :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.donate_bar</span> &#123;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">5%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.donate_bar</span> <span class="selector-tag">a</span><span class="selector-class">.btn_donate</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">82px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">82px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: auto;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif)<span class="built_in">no-repeat</span>;</span><br><span class="line"><span class="attribute">-webkit-transition</span>: background <span class="number">0s</span>;</span><br><span class="line"><span class="attribute">-moz-transition</span>: background <span class="number">0s</span>;</span><br><span class="line"><span class="attribute">-o-transition</span>: background <span class="number">0s</span>;</span><br><span class="line"><span class="attribute">-ms-transition</span>: background <span class="number">0s</span>;</span><br><span class="line"><span class="attribute">transition</span>: background <span class="number">0s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.donate_bar</span> <span class="selector-tag">a</span><span class="selector-class">.btn_donate</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">82px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.donate_bar</span> <span class="selector-class">.donate_txt</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#9d9d9d</span>;</span><br><span class="line"><span class="attribute">font</span>: <span class="number">14px</span>/<span class="number">2</span> <span class="string">"Microsoft Yahei"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.donate_bar</span><span class="selector-class">.hidden</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-donate</span>&#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#donate_guide</span>&#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">210px</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">420px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#donate_guide</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 source\css\style.styl 中添加 <span class="citation" data-cites="import">@import</span> ’_partial/donate’</p><h5 id="第三步-将打赏模块整合到文章中">第三步 : 将打赏模块整合到文章中</h5>在layout\_partial\article.ejs的<article></article><p>标签中添加 :</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; theme.donate &amp;&amp; post.donate!=<span class="keyword">false</span>)&#123; %&gt;</span><br><span class="line">&lt;%- partial(<span class="string">'donate'</span>) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h5 id="第四步-编写配置">第四步 : 编写配置</h5><p>修改 _config.yml 如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#是否开启打赏功能</span><br><span class="line"><span class="selector-tag">donate</span>: <span class="selector-tag">true</span></span><br><span class="line">#打赏文案</span><br><span class="line"><span class="selector-tag">donate_message</span>: 欣赏此文？求鼓励，求支持！</span><br></pre></td></tr></table></figure><p>Over.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我使用的主题是yilia，在此以此为例。&lt;/p&gt;
&lt;h4 id=&quot;第一步-编写打赏模块&quot;&gt;第一步: 编写打赏模块&lt;/h4&gt;
&lt;p&gt;主题文件 layout\_partial 下新建 donate.ejs , 内容如下 :&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;! -- 添加捐赠图标 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div class =&amp;quot;post-donate&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div id=&amp;quot;donate_board&amp;quot; class=&amp;quot;donate_bar center&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;a id=&amp;quot;btn_donate&amp;quot; class=&amp;quot;btn_donate&amp;quot; href=&amp;quot;javascript:;&amp;quot; title=&amp;quot;打赏&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;span class=&amp;quot;donate_txt&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;amp;uarr;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		   &amp;lt;%=theme.donate_message%&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;/span&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;br&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/div&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;div id=&amp;quot;donate_guide&amp;quot; class=&amp;quot;donate_bar center hidden&amp;quot; &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;lt;!-- 支付宝打赏图案 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;lt;img src=&amp;quot;支付宝支付图片链接&amp;quot; alt=&amp;quot;支付宝打赏&amp;quot;&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;lt;!-- 微信打赏图案 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;lt;img src=&amp;quot;微信支付图片链接&amp;quot; alt=&amp;quot;微信打赏&amp;quot;&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		document.getElementById(&amp;apos;btn_donate&amp;apos;).onclick = function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			$(&amp;apos;#donate_board&amp;apos;).addClass(&amp;apos;hidden&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			$(&amp;apos;#donate_guide&amp;apos;).removeClass(&amp;apos;hidden&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;! -- 添加捐赠图标 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://wuqiansheng.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB install</title>
    <link href="http://wuqiansheng.xyz/2016/07/29/MongoDB-install/"/>
    <id>http://wuqiansheng.xyz/2016/07/29/MongoDB-install/</id>
    <published>2016-07-29T05:54:01.000Z</published>
    <updated>2016-07-29T05:59:14.000Z</updated>
    
    <content type="html"><![CDATA[<ol type="1"><li><p>创建data,log目录<br>db: C: log: C:data.log</p></li><li><p>创建windows服务<br>mongod –logpath C:.log –logappend –dbpath C:–directoryperdb –serviceName MongoDB –install</p></li><li><p>启动 net start MongoDB</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;创建data,log目录&lt;br&gt;
db: C: log: C:data.log&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建windows服务&lt;br&gt;
mongod –logpath C:.log –logappend –dbpath C
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://wuqiansheng.xyz/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>常用知识</title>
    <link href="http://wuqiansheng.xyz/2016/04/25/%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://wuqiansheng.xyz/2016/04/25/常用知识/</id>
    <published>2016-04-25T06:31:39.000Z</published>
    <updated>2016-07-22T00:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Linux基础</strong>: http://linuxtools-rst.readthedocs.org/zh_CN/latest/index.html</p><p><strong>git基础</strong>: http://www.bootcss.com/p/git-guide/ http://streamers.github.io/blog/20160307/git-common-command.html</p><p><strong>markdown基础:</strong> https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md<br>http://www.appinn.com/markdown/</p><a id="more"></a><p><strong>Ubuntu英文版安装中文输入法:</strong> 1. Add fcitx ppa: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:fcitx-team/nightly</span><br></pre></td></tr></table></figure></p><p>or <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:fcitx-team/stable</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li><p>After you add the repository, you need to use: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p></li><li><p>Install googlepinyin: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx-googlepinyin</span><br></pre></td></tr></table></figure></p></li><li><p>Active input method : <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im-config</span><br></pre></td></tr></table></figure></p></li></ol><p>Click through and select fcitx. Click through.Restart your computer. Click the keyboard in the top right corner. Press Configure Current Input Method. Press + to add a new language. De-select “Only show current language”. Type in Google-Pinyin. Press OK. To switch between keyboards press Ctrl+Space</p><p><strong>matlab 2014b vs2015</strong> see : http://kaba.hilvi.org/homepage/blog/vs2015_in_matlab_2015/vs_2015_in_matlab_2015.htm</p><p>copy the file into: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MATLAB\R2015a\bin\win64\mexopts  </span><br><span class="line">C:\Program Files\MATLAB\MATLAB Production Server\R2015a\bin\win64\mexopts</span><br></pre></td></tr></table></figure></p><p>http://www.linuxidc.com/Linux/2008-03/11662p3.htm</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Linux基础&lt;/strong&gt;: http://linuxtools-rst.readthedocs.org/zh_CN/latest/index.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git基础&lt;/strong&gt;: http://www.bootcss.com/p/git-guide/ http://streamers.github.io/blog/20160307/git-common-command.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;markdown基础:&lt;/strong&gt; https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md&lt;br&gt;
http://www.appinn.com/markdown/&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://wuqiansheng.xyz/tags/Linux/"/>
    
      <category term="git" scheme="http://wuqiansheng.xyz/tags/git/"/>
    
      <category term="Ubuntu" scheme="http://wuqiansheng.xyz/tags/Ubuntu/"/>
    
      <category term="matlab" scheme="http://wuqiansheng.xyz/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>终于快毕业了</title>
    <link href="http://wuqiansheng.xyz/2016/04/09/%E7%BB%88%E4%BA%8E%E5%BF%AB%E6%AF%95%E4%B8%9A%E4%BA%86/"/>
    <id>http://wuqiansheng.xyz/2016/04/09/终于快毕业了/</id>
    <published>2016-04-09T07:27:28.000Z</published>
    <updated>2016-04-09T07:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间过的真快呀，大学浑浑噩噩度过了四年，没学到什么反而感觉身心俱疲，不该不该啊。惧于提前走向社会，而选择了读研的道路也不知道最终结果是好是坏，还有三年得熬呀。不过，凡事也得往好的地方想嘛。大学尚有诸多遗憾没完成，甚是遗憾，以后可没这么闲啊。趁着现在也不想做毕设，慢慢来去做啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间过的真快呀，大学浑浑噩噩度过了四年，没学到什么反而感觉身心俱疲，不该不该啊。惧于提前走向社会，而选择了读研的道路也不知道最终结果是好是坏，还有三年得熬呀。不过，凡事也得往好的地方想嘛。大学尚有诸多遗憾没完成，甚是遗憾，以后可没这么闲啊。趁着现在也不想做毕设，慢慢来去做啦
      
    
    </summary>
    
    
      <category term="生活随笔" scheme="http://wuqiansheng.xyz/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>解决JavaWeb和Mysql中文乱码问题</title>
    <link href="http://wuqiansheng.xyz/2016/04/06/JavaWeb-Mysql/"/>
    <id>http://wuqiansheng.xyz/2016/04/06/JavaWeb-Mysql/</id>
    <published>2016-04-06T07:14:09.000Z</published>
    <updated>2016-04-06T07:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先同一采用utf-8</p><p>1.数据库属性改为utf-8 必要时更改mysql的配置文件： default-character-set=utf8 character-set-server=utf8</p><p>2.连接数据库：jdbc:mysql://localhost:3306/db_bug?useUnicode=true&amp;characterEncoding=utf8</p><p>3.request中文乱码： get请求的编码方式为:ISO-8859-1 doGet方法：例子：String spotName=new String(request.getParameter(“spotName”).getBytes(“ISO-8859-1”),“UTF-8”); doPost方法:request.setCharacterEncoding(“UTF-8”);</p><p>4.response中文乱码：response.setCharacterEncoding(“UTF-8”);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先同一采用utf-8&lt;/p&gt;
&lt;p&gt;1.数据库属性改为utf-8 必要时更改mysql的配置文件： default-character-set=utf8 character-set-server=utf8&lt;/p&gt;
&lt;p&gt;2.连接数据库：jdbc:mysql://loc
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://wuqiansheng.xyz/tags/JavaWeb/"/>
    
      <category term="Mysql" scheme="http://wuqiansheng.xyz/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>My Blog With Django</title>
    <link href="http://wuqiansheng.xyz/2016/04/06/My-Blog-With-Django/"/>
    <id>http://wuqiansheng.xyz/2016/04/06/My-Blog-With-Django/</id>
    <published>2016-04-06T06:58:30.000Z</published>
    <updated>2016-04-06T07:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="environment">Environment</h1><ul><li>Python3.X</li><li>Django1.9.X</li><li>Sublime Text 3</li></ul><p>#Usage</p><p>You can use the example by doing step by step below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/wqs123/my_blog.git</span><br><span class="line">$ cd my_blog</span><br><span class="line">$ pip install -r requirement.txt</span><br><span class="line">$ python manage.py runserver</span><br></pre></td></tr></table></figure><p>Then you will see <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Performing system checks...</span><br><span class="line"></span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">March 18, 2016 - 19:40:42</span><br><span class="line">Django version 1.9, using settings &apos;my_blog.settings&apos;</span><br><span class="line">Starting development server at http://127.0.0.1:8000/</span><br><span class="line">Quit the server with CTRL-BREAK.</span><br></pre></td></tr></table></figure></p><p>Now open browser and input : http://127.0.0.1:8000/article/ ,you will see the main page like below: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7xso5r.com2.z0.glb.clouddn.com/1458301520319.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure> and http://127.0.0.1:8000/admin/ you can see the admin page: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7xso5r.com2.z0.glb.clouddn.com/1458301561606.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;environment&quot;&gt;Environment&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Python3.X&lt;/li&gt;
&lt;li&gt;Django1.9.X&lt;/li&gt;
&lt;li&gt;Sublime Text 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#Usage&lt;/p&gt;
&lt;p&gt;You
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://wuqiansheng.xyz/tags/Blog/"/>
    
      <category term="Django1.9" scheme="http://wuqiansheng.xyz/tags/Django1-9/"/>
    
      <category term="Python3.5" scheme="http://wuqiansheng.xyz/tags/Python3-5/"/>
    
      <category term="Bootstrap" scheme="http://wuqiansheng.xyz/tags/Bootstrap/"/>
    
  </entry>
  
</feed>
